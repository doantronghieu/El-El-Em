# Course: XÂY DỰNG MỘT GAME ĐƠN GIẢN BẰNG PYTHON
## Section 1: Giới thiệu tổng quan 
### Subsection 1.1: Giới thiệu chuyên gia và khóa học
Xin chào các bạn, tôi là Trọng Nghĩa và chào mừng các bạn đã đến với khóa học của tôi ngày hôm nay.
Chào các bạn tôi là Đinh Nguyễn Trọng Nghĩa, hiện tôi đang công tác tại trường Đại học Công Thương Thành phố Hồ Chí minh. Tôi đang giảng dạy tại bộ môn Khoa Học Dữ Liệu và Trí Tuệ Nhân Tạo của trường.
Tôi rất hào hứng chia sẻ với các bạn khóa học Xây Dựng Game Đơn Giản Bằng Python.
Với hơn 10 năm kinh nghiệm trong lĩnh vực lập trình và giảng dạy.
Tôi đã dành nhiều thời gian để khám phá thế giới code và nhận ra rằng
việc tạo ra những trải nghiệm trong lập trình không chỉ là một công việc mà còn là một niềm đam mê.
Tôi tin rằng việc học lập trình không chỉ giúp bạn có được những kiến thức mới mẻ mà còn giúp bạn mở ra một cánh cửa của khám phá và sáng tạo 
Chúng ta sẽ cùng nhau tìm hiểu về lập trình hướng đối tượng OOP và áp dụng kiến thức đó trong xây dựng một game đơn giản.
Trong khóa học này tôi sẽ hướng dẫn các bạn 2 nội dung chính: 
thứ nhất là lập trình hướng đối tượng với Python và thứ hai đó là lập trình game với Pygame. 
Chúng ta cũng sẽ xây dựng một cái project nho nhỏ đó là một game băng qua đường và tránh các chướng ngại vật.
Đây không phải là một khóa học dành cho các bạn hoàn toàn không biết gì về Python, các bạn cần có kiến thức cơ bản hoặc đã hoàn thành khóa học Lập Trình Cơ Bản Với Biến Và Vòng Lặp.
Sau khi hoàn thành khóa học này các bạn sẽ có kiến thức vững chắc về lập trình hướng đối tượng OOP với Python và trang bị cho mình một khả năng xây dựng những trò chơi với Pygame và có thể mở rộng sáng tạo theo ý muốn của mình.
Tôi mong rằng qua khóa học này các bạn không chỉ học được về kỹ thuật lập trình mà còn có cơ hội thực hành và tự tạo cho mình những sản phẩm mà các bạn cảm thấy tự hào. Hãy sẵn sàng cho một cuộc hành trình học tập và đầy sáng tạo. 
## Section 2: Giới thiệu lập trình hướng đối tượng với Python 
### Subsection 2.1: Giới thiệu lập trình hướng đối tượng với Python 
Phần đầu tiên trong khóa học tôi sẽ giới thiệu cho các bạn về lập trình hướng đối tượng trong Python.
Trong phần này chúng ta sẽ làm việc với Tuples, Lists, Dictionaries. Mặc dù những kiểu dữ liệu này nó không thực sự là hướng đối tượng tuy nhiên thì chúng ta cũng sẽ giới thiệu về những cái kiểu dữ liệu này. Sau đó thì chúng ta sẽ giới thiệu qua về hàm và cuối cùng thật sự chúng ta sẽ tạo ra những cái Class và những Object.
Trong bài học đầu tiên thì chúng ta sẽ giới thiệu về Tuples, Lists, Dictionaries.
Tuples là một cấu trúc dữ liệu bất biến có thể chứa mọi phần tử. 
Bây giờ tôi sẽ minh họa các bạn việc tạo ra một cái biến Tuples như thế nào. 
Ở đây thì tôi sử dụng dấu thăng (#) để chỉ ra rằng đây là một comment và trình phiên dịch nó sẽ bỏ qua dòng này.
Cách để tạo ra một biến Tuples thì giả sử chúng ta có: thì giả sử chúng ta có một cái biến là thang_nam_sinh bằng (=).
Để tạo ra một biến Tuples chúng ta sẽ sử dụng dấu ngoặc tròn (()) như thế này và trong đây chúng ta sẽ đưa vào các phần tử của Tuples. Ví dụ, chúng ta để là Tháng 5 phẩy đến phần tử thứ 2, 2010 như thế này. Như vậy thì cái Tuples tháng năm sinh này nó sẽ có 2 phần tử: 1 phần tử là Tháng 5 và 1 phần tử là 2010. 
Lưu ý rằng là khi 1 Tuples được tạo ra thì nó không thể thay đổi chính vì vậy kiểu dữ liệu Tuples là một kiểu dữ liệu bất biến.
Để truy xuất 1 phần tử trong Tuples thì chúng ta sử dụng chỉ số giống như là một mảng, ví dụ đây chúng ta sử dụng print và in ra biến tháng năm sinh để dấu ngoặc vuông ([ ]) và sau đó đến chỉ số. Ví dụ chúng ta có chỉ số là 0, rồi chúng ta có thể chạy thử bằng cách là bấm Ctrl dấu nhái ở kế bên cái số 1 (`) để chúng ta mở cái terminal. 
Chúng ta sẽ có Python và sau đó đến tên của cái file này. Ở đây thì các bạn chú ý rằng cái thư mục chúng ta là 01 OOP do đó thì ở đây chúng ta sẽ quay về cái thư mục trước CD 01 OOP. Rồi chúng ta đã vào cái thư mục 01 OOP, giờ chúng ta sẽ gõ tiếp Python tuple_list_dictionary.py và chúng ta thấy rằng là xuất ra cho chúng ta kết quả đó là tháng năm, hay nói khác là cái Tuples này nó đã truy xuất được cái phần tử đầu tiên với cái index là 0.
Chúng ta sẽ tiếp tục chuyển qua một cái cấu trúc dữ liệu tiếp theo đó là Lists. 
Tương tự như Tuples, Lists có thể chứa nhiều phần tử khác nhau và một cái điểm khác biệt đối với Tuples đó là Lists có thể thay đổi được sau khi chúng ta đã khởi tạo. 
Ví dụ này chúng ta có một cái danh sách số, để cải tạo một Lists thì ta sẽ sử dụng dấu ngoặc vuông ([ ]). Giả sử đây tôi khởi tạo là 6, 7, 8, 9.
Một cái Lists thứ 2 đó là danh_sach_ten. Ví dụ đây chúng ta khởi tạo là An, Bình và Cường. Để truy xuất chúng ta thực hiện hoàn toàn tương tự như Tuples, ví dụ đây chúng ta in ra, print danh sách số và chỉ số là 3. Một Lists thì nó sẽ bắt đầu từ 0, như vậy đây chúng ta có 0, 1, 2, 3 thì danh sách số 3 nó sẽ xuất ra số 9 cho mình. Đây chúng ta có thể chạy thử trên cái terminal. Đây chúng ta save lại trước khi chạy. Rồi ở đây thì ta thấy rằng xuất ra cho chúng ta tháng năm là cái kết quả của phía trên và số 9 là cái danh sách số với cái index là 3.
Sau khi chúng ta khởi tạo một Lists chúng ta hoàn toàn có thể thêm những phần tử khác vào trong một Lists.
Ví dụ đây chúng ta có thể gọi danh_sach_so.append, có nghĩa là hàm append này sẽ giúp chúng ta thêm một phần tử vào trong một Lists. 
Ví dụ chúng ta thêm số 10.
Và sau đó chúng ta có thể in ra cái danh_sach_so.
Trở lại khi chúng ta thấy kết quả 6, 7, 8, 9, 10. Một cái Lists này đã được thêm vào một phần tử. 
Ngoài ra thì chúng ta có thể remove hay là xóa một phần tử từ trong một Lists.
Ví dụ đây chúng ta gọi anh_sach_so.remove thì chúng ta có thể xóa một phần tử, ví dụ ta để vào số 7, lệnh này sẽ xóa phần tử mang giá trị số 7. Đây chúng ta có thể chạy lại bằng Python tuple_list_dictionary thì chúng ta thấy phần tử số 7 đã được xóa khỏi Lists. Tương tự chúng ta có một cái hàm đó là hàm Del dùng để xóa một phần tử với một cái chỉ số nhất định.
Ví dụ đây, chúng ta gọi del(danh_sach_so[2]), thì hiện tại cái danh sách số của mình là 6, 8, 9 và 10 thì phần tử có index là 2 đó là số 9 sau khi chúng ta gọi cái này thì nó sẽ xóa cho chúng ta cái phần tử số 9. Chúng ta có thể in lại print(danh_sach_so). Chúng ta thấy là sau khi xóa xong danh sách số ta còn 6, 8 và 10.
Một cái cấu trúc dữ liệu thứ ba đó là Dictionary. Dictionary cho phép chúng ta lưu dữ liệu dưới dạng một cái cặp Key và Value hay còn gọi là khóa và giá trị. 
Đây chúng ta sẽ tạo ra một cái Dictionary mới.
Ví dụ chúng ta có thong_tin_sinh_vien, để tạo một Dictionary thì chúng ta sẽ sử dụng dấu ngoặc nhọn ({ }) như thế này và bên trong chúng ta sẽ có những phân tử những phân tử sẽ được thể hiện dưới dạng đó là key và value và cách nhau bởi dấu 2 chấm (:).
Ví dụ chúng ta có key là tên, giá trị là Nguyễn Văn A. Để tạo một phần tử khác chúng ta sẽ để dấu phẩy (,) 
Cái key tiếp theo là tuoi: 20. Và một cái key là lop: 
12A.
Giả sử chúng ta tạo thêm một cái Dictionary, diem_so bằng mở ngoặc nhọn ({) đóng ngoặc nhọn (}), Toan:9, Van: 8 và điểm Anh: 7. 
Để truy xuất đến một Dictionary, chúng ta không truy xuất bằng index mà chúng ta sẽ truy xuất bằng những cái key. Ví dụ đây chúng ta print thong_tin_sinh_vien, mở ngoặc vuông ([) ra và trong đây chúng ta sẽ để một cái key, ví dụ đây chúng ta để là ten thì nó sẽ xuất ra chúng ta cái giá trị của cái thông tin sinh viên tên. Có nghĩa là Nguyễn Văn A, đây chúng ta có thể chạy thử ở trên terminal của mình. 
Rồi okey ở đây thì chúng ta có một cái lỗi là chỗ 12A, thì 12A này nó không phải là một giá trị số, do đó chúng ta phải để cái dấu ngoặc vào (12A), để nó trở thành một cái giá trị là chuỗi. Rồi chúng ta sẽ run lại bằng terminal thì chúng ta thấy là xuất ra Nguyễn Văn A cho chúng ta. Bởi vì chúng ta truy xuất đến Dictionary thông qua một cái key đó là thong_tin_sinh_vien[ten].
Tiếp theo thì tôi sẽ giới thiệu cho các bạn một khái niệm đó là hàm. Hàm là một khái niệm khá quan trọng giúp cho cái chương trình của mình nó dễ quản lý hơn bằng cách là chia nhỏ những cái đoạn code.
Ở đây thì tôi tạo ra một cái file mới đó là function.py để chúng ta dễ làm việc. Thì đây tôi sẽ định nghĩa một cái hàm.
Chú ý rằng hàm là một khối mà lệnh độc lập và có thể gọi để thực thi một cái công việc cụ thể nào đó. Để tạo ra một hàm thì chúng ta sẽ sử dụng một cái từ khóa đó là Def, D E F như thế này, sau đó đến tên hàm. Giả sử tôi muốn sử dụng một cái hàm để tính tổng thì đây tôi để là def tính tổng.
Sau đó chúng ta sẽ mở ngoặc, mở ngoặc tròn (() như thế này, bên trong hàm chúng ta sẽ đưa vào đó là những thông số của hàm. Ví dụ trong trường hợp này chúng ta cần 2 thông số đó là a và b. Khi người ta gọi hàm thì người ta sẽ đưa 2 cái thông số đó là a và b tương ứng vào. Cuối cùng đến 2 chấm (:) và bên trong hàm này chúng ta sẽ thực hiện một số cái logic để thực thi một cái tác vụ nào đó, trong trường hợp này chúng ta tính tổng a và b và trả về cái kết quả là tổng thu được. Như vậy ở đây chúng ta sử dụng một cái từ khóa là return để trả về một kết quả và đây chúng ta sẽ trả về a cộng b.
Nếu chúng ta làm rõ hơn thì chúng ta có thể tạo ra một cái biến tổng bằng a cộng b ( tong = a + b) sau đó thì chúng ta sẽ return ra cái biến tổng này.
Như vậy thì chúng ta đã định nghĩa được một cái hàm. 
Muốn gọi hàm chúng ta gọi đến cái tên hàm là thành công. 
Giả sử tôi muốn cộng 2 số, ví dụ là 5 và 3, thì đây tạo một cái biến là ket_qua, sau đó gọi đến hàm tinh_tong mở ngoặc. Trong đây chúng ta phải đưa vào 2 thông số đó là a và b, đương nhiên là các giá trị đưa vào đều được. Thì đây chúng ta sẽ đưa vào 2 giá trị đó là 5, 3. 
Như vậy thì cái biến kết quả này sẽ là kết quả sau khi mà cái hàm tính tổng này thực hiện tổng của 5 và 3, hay nói cách khác là 5 đưa vào cái biến a này, 3 đưa vào biến b này và nó trở thành tổng là 5 cộng 3 là 8 và nó return trở lại.
Sau khi return thì giá trị này sẽ được đưa vào ket_qua. Bây giờ chúng ta có thể in ra để thử. Đây chúng ta sẽ in ra, print(ket_qua) và chúng ta có thể chạy thử trên cái terminal. Python, function.py như thế này. Enter. Kết quả trả về sẽ là giá trị là 8.
Như vậy thì ở đây các bạn biết được cái cách tạo một hàm mới và một cái cách đó là gọi hàm.
Phần tiếp theo này chúng ta sẽ tìm hiểu về lập trình hướng đối tượng và chúng ta sẽ tạo ra những cái lớp.
Cái khái niệm quan trọng nhất trong lập trình hướng đối tượng đó là những lớp. Lập trình hướng đối tượng giúp chúng ta có thể mô hình hóa cái thế giới thực của mình và xây dựng cái mã code của chúng ta linh hoạt hơn.
Trong lập trình hướng đối tượng thì chúng ta sẽ có 2 cái khái niệm đó là lớp và đối tượng.
Lớp là một khuôn mẫu để định nghĩa các phương thức và thuộc tính của đối tượng. Lớp mô tả cách mà đối tượng sẽ hoạt động.
Và cái khái niệm thứ 2 đó chính là đối tượng. Đối tượng thì chúng ta sẽ là thực thể hóa của một lớp.
Xóa 17:10 - 17:13
Trong đối tượng nó sẽ chứa những thông tin cụ thể và có khả năng thực hiện những hành động của một lớp.
Rồi ở đây thì tôi sẽ tạo ra một cái lớp mới.
Để tạo một lớp thì chúng ta sẽ sử dụng từ khóa là Class sau đó đến tên lớp. Giả sử tôi tạo ra một lớp là SinhVien, sau đó đến 2 chấm (:).
Trong một lớp thì chúng ta cần một cái phương thức gọi là phương thức khởi tạo của lớp. 
Ví dụ đây chúng ta định nghĩa một phương thức khởi tạo. Một phương thức khởi tạo chẳng qua là một hàm bên trong lớp mà thôi.
Do đó thì chúng ta cũng sẽ sử dụng từ khóa def để định nghĩa giống như định nghĩa hàm. Tuy nhiên thì cái tên hàm trong trường hợp này nó hơi đặc biệt chút xíu và do Python quy định là chúng ta sử dụng là gạch gạch (__) init sau đó đến gạch gạch (__) như thế này. Khi mà gặp một cái hàm với cái tên đặc biệt như thế này thì Python hiểu rằng chúng ta đang muốn tạo ra một phương thức khởi tạo.
Trong phương thức cải tạo thì chúng ta cũng có thể đưa vào những thông số. Ví dụ như trong trường hợp này chúng ta sẽ đưa vào tên và tuổi của sinh viên, tuy nhiên có một điều các bạn lưu ý rằng đó là trong bất kỳ một phương thức nào của một lớp thì chúng ta phải có thêm một cái từ khóa đó là Self để chỉ lại chính cái lớp đó. Rồi như vậy thì đây chúng ta sẽ có (self, ten, tuoi): 
Để khế tạo một lớp thì đơn giản nhất là chúng ta sẽ sử dụng là self chấm tên sẽ bằng tên rồi ở đây thì, ở đây thì tôi sẽ giải thích thêm về cái câu lệnh này. Ở đây chúng ta có một cái từ khóa Self sau đó đến dấu chấm (.) và đến chữ tên (self.ten). Từ khóa self này để chỉ về chính cái lớp mà chúng ta đang làm việc, ví dụ Self này chính là lớp sinh viên, chấm (.) là chúng ta truy xuất đến các thành phần của cái lớp và sau đó đến tên và sau đó đến tên là một thuộc tính của lớp.
Như vậy trong dòng này bên trái của phép gán chúng ta có đó là tạo ra một thuộc tính mới của cái lớp sinh viên, đó là tên. Sau đó chúng ta gán vào cái giá trị tên ở đây thì tên này mặc dù là cái chữ này nó giống chữ bên đây, tuy nhiên cái tên ở đây nó chính là cái thông số truyền vào của cái hàm khởi tạo.
Rồi tương tự như vậy chúng ta sẽ có sao chấm tuổi bằng tuổi. Như vậy hàm khởi tạo này làm 2 việc: thứ nhất khởi tạo ra 2 cái thuộc tính: đó là tên và tuổi trong lớp sinh viên, và cái thứ 2: gán 2 cục tính này cho 2 cái thông số đầu vào.
Bây giờ chúng ta sẽ tạo một cái đối tượng mới dựa trên cái lớp sinh viên này.
Để tạo một đối tượng thì chúng ta sẽ sử dụng một cái biến nè SV1 bằng sau đó đến gọi đến cái lớp. Lớp sinh viên mở ngoặc ra, thì khi chúng ta gọi đến một cái lớp nào đó và chúng ta mở ngoặc như thế này có nghĩa là chúng ta đang gọi đến một hàm khởi tạo.
Chúng ta sẽ truyền vào 2 cái thông số: thứ nhất là tên, thứ 2 là tuổi. Ví dụ Nguyễn Văn A phẩy (,); thông số thứ 2 là tuổi, chúng ta đưa vào 20. Như vậy với dòng này chúng ta khởi tạo được một cái đối tượng đó là SV1, cái đối tượng này thuộc cái lớp là sinh viên. Tuy nhiên hiện tại thì chúng ta có cái lớp này chưa có thông tin gì cả chúng ta chỉ mới khởi tạo mà không thực hiện một cái tác vụ nào hết, bây giờ chúng ta sẽ viết một cái hàm để thực hiện một cái tác vụ đó là một cái hàm giới thiệu.
Def giới thiệu. Hàm thì chú ý luôn luôn có từ khóa là self. Ở đây chúng ta sẽ in ra một câu đơn giản thôi, print - 
Đây chúng ta sẽ in ra “Xin chào tôi tên là” và chúng ta để một cái dấu ngoặc nhọn ({) như thế này sau đó chèn một biến vào, cái biến mà chúng ta chèn chính là cái thuộc tính của cái lớp đó là self chấm tên, self chấm tên phẩy.
Tiếp tục chúng ta sẽ chèn tuổi vào đó là self chấm tuổi. Nếu chúng ta viết như thế này ta truyền cái Nguyễn Văn A vào đây được lưu trong self chấm tên, truyền số 20 vào đây được lưu trong self chấm tuổi và khi chúng ta gọi một cái hàm giới thiệu thì chúng ta sẽ thấy rằng là nó sẽ xuất ra chúng ta “Xin chào tôi tên là Nguyễn Văn A 20 tuổi”.
Bây giờ chúng ta sẽ xuất ra SV1 bằng. Bây giờ chúng ta sẽ gọi đến cái phương thức giới thiệu này bằng cách là SV1 chấm giới thiệu mở ngoặc đóng ngoặc mà không cần một thông số gì cả. Tất cả thông số chúng ta đã truyền vào khi chúng ta khởi tạo. Rồi bây giờ chúng ta sẽ nên thử save lại và lên thử Python Class.
Đây nó sẽ xuất ra chúng ta đó là “Xin chào tôi tên là Nguyễn Văn A 20 tuổi”; tương tự như vậy bởi vì chúng ta có một Class do đó chúng ta có thể tạo ra bao nhiêu đối tượng tùy ý. Giả sử chúng ta có một cái đối tượng sinh viên 2 khởi tạo bằng Class sinh viên với cái tên là Trần Thị B và tuổi là 22 tuổi, thì tương tự chúng ta cũng có thể gọi đến SV2 chấm giới thiệu, rồi chúng ta sẽ chạy thử. Thì đây chúng ta thấy xuất ra 2 dòng: 1 dòng là tôi là Nguyễn Văn A 20 tuổi và 1 dòng thứ hai tôi tên là Trần Thị B 22 tuổi. Như vậy đây chính là một Class và cách để chúng ta hiện thực hóa một Class bằng cả là khởi tạo nên một cái đối tượng mới.
Một tính năng rất đặc biệt trong lập trình hướng đối tượng đó là chúng ta có thể tạo nên các lớp con và sự kế thừa. 
Lớp con đó là một lớp được tạo nên từ một lớp đã tồn tại và có khả năng kế thừa tất cả những thuộc tính và những cái phương thức của lớp cha.
Rồi bây giờ để minh họa cho việc sử dụng lớp con thì tôi tạo ra trước hết một lớp cha. Class nhân viên. - 
Đầu tiên chúng ta sẽ tạo ra một hàm khởi tạo - init. Trong đây thì chúng ta sẽ để 2 thông số: thứ nhất là tên, thứ 2 là lương. Rồi đơn giản nhất chúng ta sẽ self chấm tên bằng tên và self chấm lương bằng lương. Trong lớp nhân viên này thì chúng ta sẽ tạo ra một cái method, một cái phương thức def giới thiệu self.
Đây thì chúng ta sẽ in ra một thông tin thôi. Print “tôi là” đưa vào đây self chấm tên; lương đưa vào đây self chấm lương. Rồi ở đây thì chúng ta thiếu 1 dấu 2 chấm. Như vậy thì chúng ta đã hoàn thành một cái lớp là nhân viên. Bây giờ chúng ta sẽ sử dụng cái lớp nhân viên này để tạo ra một cái đối tượng object. NV1, đây chúng ta viết liền ra luôn đi nhân viên 1 bằng. Để khởi tạo thì chúng ta sử dụng là tên lớp mở ngoặc sau đó truyền thông số vào, ví dụ đây Nguyễn Văn A, lương 5000 và gọi một cái phương thức nhân viên 1 chấm giới thiệu. Rồi bây giờ chúng ta sẽ chạy thử.
Python Subclass.py. Kết quả chúng ta rõ ràng xuất ra tôi là Nguyễn Văn A, vậy lương là 5000. Như vậy thì cái này là hoàn toàn giống như cái bài học trước chúng ta đã làm tạo một cái lớp lấy một cái object để khởi tạo từ lớp và gọi một cái phương thức từ cái lớp đó.
Bây giờ chúng ta sẽ minh họa tiếp về cái lớp con. Để tạo ra lớp con chúng ta cũng sử dụng từ khóa là lớp, là Class như thế này và tên lớp. Ví dụ đây: giám đốc thì rõ ràng giám đốc cũng là một nhân viên do đó thì chúng ta sẽ mở ngoặc và để cái lớp nhân viên vào đây. Đây các bạn sẽ thấy là cái cách mà chúng ta khai báo một cái lớp nó khác so với ở trên. Ở trên thì chúng ta để nhân viên và 2 chấm, ở đây thì giám đốc và mở ngoặc ra để nhân viên có nghĩa là giám đốc là một lớp con của nhân viên, giám đốc được kế thừa tất cả những thuộc tính và phương thức của cái lớp nhân viên này. Hiện tại thì chúng ta chưa muốn viết một thông tin nào liên quan đến các class giám đốc do đó thì đây chúng ta có thể để là pass như thế này. Khi chúng ta để pass thì có nghĩa là tạm thời chúng ta chưa biết code trong cái phần đó.
Tuy nhiên thì cái class giám đốc vẫn hoạt động, ví dụ đây chúng ta tạo ra một cái nhân viên 2. Nhân viên 2 và khởi tạo ban giám đốc mở ngoặc, rõ ràng lớp giám đốc chưa có được định nghĩa cái hàm init tức là cái hàm khởi tạo tuy nhiên khi chúng ta mở ngoặc ra thì chúng ta thấy nó vẫn yêu cầu tên và lương.
Bởi vì lớp giám đốc được kế thừa từ lớp nhân viên do đó cái hàm khởi tạo này cũng được kế thừa. Rồi ở đây chúng ta sẽ truyền vào Trần Thị B, phẩy, 10.000. Và bên dưới này chúng ta cũng gọi nhân viên 2 chấm giới thiệu chúng ta sẽ thấy rằng mặc dù nhân viên 2 là một cái đối tượng của lớp giám đốc, lớp giám đốc chưa được khai báo một cái hàm nào giới thiệu cả, tuy nhiên vẫn có thể gọi đến cái hàm giới thiệu. Bởi vì sao, bởi vì giám đốc là kế thừa từ lớp nhân viên do đó cái hàm giới thiệu này vẫn được sử dụng. Đây chúng ta có thể chạy thử Python. Và ở đây chúng ta thấy là nó vẫn xuất ra tôi là Trần Thị B với lương là 10.000 cực kỳ tuyệt vời.
Tuy nhiên trong một số trường hợp chúng ta muốn viết lại một cái phương thức nào đó, ví dụ như ở đây giám đốc muốn giới thiệu kiểu khác thì chúng ta có thể là viết lại cái hàm giới thiệu này. Bây giờ chúng ta sẽ bỏ đi cái chữ pass sau đây. Để viết lại thì chúng ta ghi Def, giới thiệu self và trong đây cái thân hàm thì chúng ta cứ việc viết lại một cái mới, ví dụ đây chúng ta print tôi là giám đốc ở đây. Chúng ta sẽ để là self chấm tên phẩy, lương self chấm lương. Như vậy thì rõ ràng đối với trường hợp là class là giám đốc thì trong class này hoàn toàn có thể viết lại một cái phương thức của lớp cha và muốn và ở đây chúng ta muốn viết lại như thế nào là toàn quyền đã không bị bắt buộc bởi không bị bắt buộc bởi cái phương thức được định nghĩa ở lớp cha. Rồi chúng ta có thể chạy lại, thì lúc này chúng ta thấy nhân viên thì vẫn giới thiệu theo cách thông thường tôi là Nguyễn Văn A lương 5.000 đối với trường hợp một cái object được khởi tạo từ lớp giám đốc thì chúng ta thấy ở đây có một cái cách giới thiệu khác đó là tôi là giám đốc Trần Thị B lương 10.000.
Như vậy thì trong phần này tôi đã giới thiệu cho các bạn về lớp con và sự kế thừa từ lớp cha, ngoài ra thì chúng ta cũng viết lại một cái hàm chúng ta gọi là overwrite) một cái phương thức từ lớp cha để lớp con có thể thể hiện những cái phương thức khác của lớp cha mặc dù là cùng tên.
## Section 3: Giới thiệu Pygame và cách xây dựng game với Python
### Subsection 3.1: Giới thiệu Pygame và cách xây dựng game với Python
Tiếp theo thì chúng ta sẽ đến với phần 2 của khóa học đó là giới thiệu về Pygame và cách xây dựng game với Python. 
Ở đây thì tôi sẽ giới thiệu với bạn về cái trang web của Pygame, đó là Pygame.org. Chúng ta sẽ thấy một số thông tin liên quan đến cái gói Pygame này.
Pygame là một thư viện mã nguồn mở trong Python, nó tập trung vào việc phát triển trò chơi và các ứng dụng đa phương tiện, nó cung cấp chúng ta công cụ cho việc xử lý đồ họa, âm thanh, sự kiện và nhiều chức năng khác. Ở đây thì các bạn có thể vào trong cái about để chúng ta xem thêm những thông tin liên quan đến cái Pygame này chúng ta cũng thể vào cái getting started để bắt đầu với cái Pygame. 
Bây giờ tôi sẽ hướng dẫn các bạn cài đặt liên quan đến cái Pygame này.
Chúng ta sẽ mở cmd. Để cài đặt Pygame, chúng ta sẽ sử dụng một cái lệnh đó là VIP install (?) Pygame. Ở đây giả định rằng máy tính của các bạn đã được cài Python khi chúng ta gọi lệnh VIP install (?) Pygame thì nó sẽ download cái khối Pygame và cài đặt lên máy tính chúng ta.
Quá trình cài đặt thì cũng nhanh chóng và tùy thuộc vào tốc độ của máy tính của mình.
Rồi như vậy thì quá trình cài đặt đã thành công. Bây giờ chúng ta sẽ kiểm tra thử xem là nó có thành công hay không. Bây giờ chúng ta sẽ gõ ipython đây là cái dấu nhắc của ipython và đơn giản chúng ta sử dụng một cái lệnh là import Pygame. Nếu import thành công có nghĩa là Pygame đã được cài đặt. ở đây chúng ta sẽ thấy được cái version mà cái Pygame cài đặt, thì hiện tại Pygame được cài đặt trên máy tính với version là 2.5.1 và Python là version 3.10.9.
Như vậy thì với cái gói thư viện Pygame chúng ta có thể bắt đầu viết những cái game của chính mình.
### Subsection 3.2: Cách xây dựng game với Python
Tiếp theo thì tôi sẽ giới thiệu cho các bạn về cách để thiết lập những cái display, những cái thông số khi chúng ta bắt đầu thực hiện game. Những cái thông số thì nó sẽ bao gồm là kích thước màn hình và hình nền.
Bây giờ chúng ta sẽ tạo một cái file mới. Ở đây thì tôi tạo một cái là pygame.py. Trước khi bắt đầu một cái project liên quan đến Pygame thì chúng ta sẽ sử dụng một cái lệnh là import Pygame. Import Pygame. Để import cái gối Pygame này và chúng ta sẽ bắt đầu sử dụng.
Sau khi import thì chúng ta sẽ khởi tạo cái Pygame này bằng lệnh Pygame chấm (.) init. Pygame.init, nhớ rằng là chúng ta phải mở ngoặc và đóng ngoặc.
Tiếp theo chúng ta sẽ tạo cửa sổ đồ họa bằng cách là quy định chiều rộng và chiều cao.
Tạo cửa sổ đồ họa. Ở đây chúng ta sẽ sử dụng 2 cái hàng số, ta đặt là width: 800 và chiều cao: 800.
Để khởi tạo một cửa sổ đồ họa thì chúng ta sẽ gọi đến cái screen.
Đây chúng ta đặt một cái biến là screen.
Và gọi đến Pygame chấm (.) display chấm (.) set mode. Ở đây chúng ta chấm thì Visual Studio Code sẽ giúp chúng ta hiển thị một số cái gợi ý là chúng ta sẽ chúng ta sẽ tiện hơn trong quá trình gõ code.
Trong hàm set mode này, thứ nhất chúng ta sẽ cung cấp đó là size đó là kích thước của chiều rộng và chiều cao của cửa sổ đồ họa của mình. Chúng ta sử dụng một cái Tuples mở ngoặc ra như thế này, sau đó truyền vào width và height.
Rồi những thông số còn lại chúng ta hoàn toàn có thể để mặc định.
Tiếp theo chúng ta sẽ định nghĩa màu nền của cái cửa sổ của mình. Thay đổi màu nền cửa sổ.
Ở đây thì từng dòng tôi đều có để comment để các bạn dễ theo dõi chúng ta gọi một cái hàm số là background color.
Để định nghĩa một cái color - một cái màu thì chúng ta có thể sử dụng một cái Tuples trong đó chứa ba cái thông số đó là Red, Green và Blue. Ví dụ đây để 255, 255 và 255.
Để thiết lập màu của màn hình thì ở đây chúng ta sử dụng Green. Biến Green thì chúng ta đã khởi tạo bằng cách là gọi pygame display set mode, screen chấm (.) fill và truyền vào đây đó là cái màu thì màu chúng ta đã định nghĩa ở trong cái background color. 
Và cuối cùng chúng ta có pygame chấm (.) display chấm (.) update. Hàm update là một cái hàm khá quan trọng ở trong Pygame, hàm update này khi chúng ta thực hiện một cái thay đổi nào đó trên màn hình thì chúng ta nhớ gọi cái hàm update để cập nhật lại lên trên màn hình.
Để hiển thị lên trên một cái ứng dụng game của mình chúng ta sẽ cần một cái vòng lặp game. Bài học tiếp theo thì tôi sẽ giới thiệu qua về vòng lặp game tuy nhiên ở đây để hiển thị lên thì chúng ta cũng cần đến cái vòng lặp cho nên tôi sẽ đợi một cái vòng lặp đơn giản nhất ở trong cái file này.
Rồi chúng ta có một cái biến running là True. 
Và vòng lặp game này thì ở đây chúng ta sẽ để một cái vòng lặp while running 2 chấm (:). Tức là khi cái biến running này còn đúng thì chúng ta sẽ còn chạy cái phần code ở bên dưới này. Trong đây thì chúng ta sẽ có một cái vòng lặp để duyệt qua các event của cái Pygame này, for event in Pygame chấm event chấm get mở ngoặc đóng ngoặc (()). 
If event bằng với pygame chấm quit thì running chúng ta sẽ gán cho là False 
và bên ngoài vòng lặp thì chúng ta sẽ kết thúc Pygame khi, khi hoàn thành một cái chương trình Pygame thì chúng ta nhớ gọi một cái lệnh đó là quit.
Chúng ta gọi pygame chấm quit như vậy thì chúng ta đã hoàn tất một cái chương trình đầu tiên. Chương trình này cực kỳ đơn giản chúng ta tạo một cửa sổ đồ họa với kích thước là 800 và 800. Sau đó thì chúng ta tô màu trong cái cửa sổ này với cái màu là 255, 255, 255. Các bạn có đoán được là cái màu này là màu gì hay không? Bây giờ tôi sẽ chạy thử cái chương trình của mình.
Python mygame.py. Ở đây chúng ta thấy xuất hiện một cái cửa sổ đồ họa này nó là màu trắng cửa sổ này có kích thước là 800x800 và khi chúng ta tích vào cái dấu chéo này thì cái chương trình chúng ta nó sẽ thoát. 
Rồi chúng ta thấy là hiện tại tích vào nó vẫn không thoát thì chúng ta đã thiếu, thì ở đây chúng ta đã thiếu một cái vấn đề đó là chúng ta kiểm tra cái thoát ở đây không phải là event, ở đây phải là event chấm type, đây kiểm tra là pygame thoát thì chúng ta sẽ dừng cái vòng lặp này nếu không vòng lặp này nó sẽ chạy vô hạn.
Quay lại đây chúng ta sẽ chạy lại chương trình của mình. Và nếu chúng ta đánh dấu chéo thì nó sẽ thoát cái phần mềm của mình.
Trong cái phần hiển thị cửa sổ trong cái set mode này chúng ta cũng hoàn toàn có thể thêm vào một cái thông số. Đó là pygame chấm Resizable đây. Nếu chúng ta có một cái thông số này đối với cửa sổ thì cửa sổ của chúng ta có thể thay đổi kích thước được. Đây trong trường hợp này cửa sổ có thể thay đổi kích thước theo chúng ta mong muốn, tuy nhiên thông thường trong một ứng dụng game cái việc mà thay đổi kích thước nó sẽ ảnh hưởng đến chất lượng hình ảnh cũng như là cái sự thay đổi cũng như là cái be happier của game của mình do đó thì tôi vẫn khuyến cáo các bạn là không nên để thêm cái thông số Pygame chấm Resizable. Như vậy thì tôi giới thiệu cho các bạn về cái display trong Pygame.
Tiếp theo thì tôi sẽ giới thiệu cho các bạn về game loop hay nói khác là vòng lặp game.
Trong cái code này thì chúng ta thấy từ cái while running cho đến đây thì đây là một cái đoạn gọi là vòng lặp game. Game loop là một vòng lặp chính trong trò chơi và trong đây cái trạng thái của trò chơi nó sẽ được cập nhật liên tục để những hình ảnh có thể được hiển thị lên. Vòng lặp này sẽ chạy liên tục giúp trò chơi chúng ta hoạt động mượt mà hơn. 
Thì ở đây chúng ta có một cái biến là running, thể hiện giá trị là True và khi running thì chúng ta sẽ có một cái vòng lặp là while chạy liên tục. Trong vòng lặp này thì trước hết sử dụng một cái vòng lặp for là event chạy qua tất cả những cái sự kiện diễn ra trong cái trò chơi của mình. Trong đây thì chúng ta có một cái if nếu như cái event type là quit thì chúng ta sẽ cho cái running này trở thành False và vòng lặp này nó sẽ dừng lại thoát ra ngoài.
Khi chúng ta làm việc với vòng lặp game thì chúng ta cũng nên nói thêm một cái khái niệm đó là clock, tức là đồng hồ. Khi các bạn chơi game thì chúng ta biết đến một khái niệm đó là FPS hay nói khác là frames-per-second, số khung hình trong mỗi giây. Điều này quyết định game chúng ta nó chạy mượt hay không. Thông thường các game nó được xét ở cái frames-per-second đó là 60 thì bây giờ tôi sẽ thiết lập cái frames-per-second này.
Rồi đầu tiên bên ngoài phòng lập chúng ta sẽ thực hiện một cái thiết lập thời gian hay nói cách khác là khởi tạo cái biến clock của chúng ta. 
Chúng ta khởi tạo bằng cách là gọi một cái biến clock bằng pygame chấm time chấm clock như thế này. Bên trong vùng lập thì chúng ta gọi lại cái biến clock này. Đây chúng ta gọi clock chấm tick và đưa vào đây một con số, thì con số này ở trong đây nó hướng dẫn mình đó là frames-per-second hay nó khác đó là FPS ví dụ đây chúng ta để là 60, khi chúng ta để một cái lệnh đó là clock chấm tick 60 thì cái game của mình nó thì cái game của mình nó sẽ được chạy với cái tốc độ đó là 60 khung hình mỗi giây. Thông thường thì trong vòng lặp chúng ta còn gọi thêm một cái lệnh nữa đó là lệnh update.
Ở đây chúng ta thấy có một cái lệnh bên ngoài đó là pygame chấm display chấm update thì cái lệnh này nên để trong cái vòng lặp có nghĩa là mỗi vòng lặp game thì cái game của mình nó sẽ update một lần, update những cái vị trí của những cái nhân vật những cái vị trí của nhân vật hoặc là những cái đồ họa mà chúng ta mới thêm vào trong cái game của mình.
Như vậy thì trong phần này tôi đã giới thiệu cho các bạn về vòng lặp game về cách thiết lập cái thời gian trong game và cái cách mà chúng ta update đồ họa trong game.
Tiếp theo thì tôi sẽ hướng dẫn các bạn cơ bản về những cái vẽ ở trong Pygame. 
Các bạn có thể truy cập vào trang web của Pygame kiểm tra mục documentation thì chúng ta thấy có một cái phần là Pygame.draw. Thì ở đây có một số cái mô đun để chúng ta có thể vẽ những cái hình đơn giản ví dụ như là vẽ một cái hình chữ nhật, vẽ đa giác, vẽ hình tròn, vẽ e líp,v.v. thì đây có rất nhiều hàm để chúng ta ở đây có rất nhiều hàm để hỗ trợ cho các bạn trong việc vẽ những cái hình đơn giản. 
Bây giờ tôi sẽ minh họa bằng cách là vẽ một số đường tròn ngẫu nhiên và hiển thị lên trên cái màn hình. Đầu tiên chúng ta sẽ thiết lập cái số lượng. Số lượng đường tròn vẽ mỗi vòng lặp. Giả sử thì tôi để đây 5 là 1. Giả sử đây để thiết lập là 5 là 2. Bên trong cái vòng lặp game chúng ta sẽ thiết lập một số cái vấn đề để có thể vẽ được. For, do không cần biến cho nên chúng ta để một dấu gạch dưới (_) như này in range 5 có nghĩa là cái vòng lặp for này sẽ được lập 5 lần và ở đây chúng ta thiết lập là 2 để vẽ được đường tròn đây chúng ta xem Pygame chấm draw chấm circle. Thì chúng ta cần một cái màn hình màn hình chúng ta đã có biến screen, chúng ta cần color, cần cái tâm và cần radius, cần bán kính của đường tròn, rồi bây giờ chúng ta sẽ định nghĩa từng cái biến đó.
Đầu tiên chúng ta sẽ định nghĩa cái tâm - center. Ở đây thì do vẽ ngẫu nhiên cho nên cái tâm cũng sẽ đạt ngẫu nhiên trên màn hình. Như vậy center chúng ta sẽ sử dụng hàm random, trước khi mà sử dụng được random thì nhớ import một cái gối thư viện, đó là gối random. Rồi ở đây thì chúng ta sẽ để là random chấm randint tức là sẽ tạo chúng ta một cái số nguyên ngẫu nhiên đây chúng ta sẽ để là 0 và width. Có nghĩa là nó sẽ trả về chúng ta một số nguyên ngẫu nhiên từ 0 đến cái chiều rộng của màn hình. Rồi tương tự như vậy cái thông số thứ 2 random chấm randint 0 đến height. Với cái này thì chúng ta sẽ phát sinh ra được một cái tâm ngẫu nhiên cho đường tròn và chắc chắn rằng cái đường tròn này tâm sẽ nằm trong cái phần của cái màn hình của mình quy định là 800 và 800.
Tiếp theo chúng ta sẽ quy định radius, có nghĩa là bán kính đường tròn thì đây bán kính chúng ta cũng sẽ để là ngẫu nhiên random chấm randint từ 10 đến 50. Đây chúng ta sẽ quy định rằng đường tròn chúng ta có bán kính là ngẫu nhiên từ 10 đến 50 pixel.
Còn một cái vấn đề đó là màu thì màu bây giờ chúng ta sẽ để ở bên ngoài vòng lặp for là color. Thiết lập màu thì màu chúng ta sẽ có ba thông số Red, Green và Blue, giả sử chúng ta sẽ đặt random cho một thông số randint từ 0 cho đến 255, 2 thông số còn lại thì chúng ta cho nó là 0. Như vậy thì chúng ta đã có đầy đủ thông số để có thể vẽ được một cái đường tròn là nó bao gồm màu nè, tâm nè và bán kính đường tròn, và đây chúng ta sẽ gọi đến một cái hàm pygame chấm draw chấm circle.
Đầu tiên là nó ghi là server thì đây chính là cái screen của mình cái màn hình. Cái thứ hai là color chúng ta sẽ truyền cảm biến color vào. Cái thứ ba là center - tâm đường tròn và cái thứ tư là radius.
Rồi bây giờ chúng ta có thể chạy thử chương trình này. Python mygame.py và chúng ta sẽ thấy những hình tròn liên tục được xuất hiện ở trên màn hình của mình và cái màu nó thiên về cái hướng màu đỏ là bởi vì ở đây chúng ta để là color là red nè thì random 255 nhưng mà màu green và màu blue thì chúng ta để là 0. Nếu chúng ta sửa cái này lại cả ba thông số đều là random thì chúng ta sẽ thấy màu sắc nó sặc sỡ hơn. Rồi chạy lại chương trình. Đây chúng ta thấy là những hình tròn này nó xuất hiện với nhiều màu sắc hơn và nó xuất hiện liên tục với cái tâm và cái readius nó khác nhau. 
Rồi như vậy thì trong cái phần này tôi đã minh họa các bạn việc vẽ những cái hình đơn giản với vẽ những hình tròn liên tục và ngẫu nhiên xuất hiện trên màn hình. 
Rồi tiếp theo tôi sẽ hướng dẫn các bạn cách hiển thị những hình ảnh của mình lên trên game. 
Những hình ảnh có nghĩa là những hình ảnh chúng ta được thiết kế bên ngoài chúng ta lấy từ những cái nguồn nào đó hoặc là chúng ta tự thiết kế và chúng ta đưa những hình ảnh đó lên trên cái phần mềm game của mình. Ỏ đây thì tôi có một cái hình ảnh được copy vào trong cái project đó là image.png rồi chúng ta thấy một cái hình ảnh con thỏ rất dễ thương như thế này Image.png. Để hiển thị hình ảnh lên game chúng ta sẽ cần 2 bước: thứ nhất chúng ta sẽ load hình ảnh vào một cái biến nào đó.
Ở đây tôi gọi hình ảnh này là image và để load hình ảnh thì chúng ta sử dụng pygame chấm image chấm load mở ngoặc đóng ngoặc. Ở đây chúng ta thấy là nó nhắc mình đó là file name có nghĩa là chúng ta cần đưa cái tên file vào thì đây tên file là image.png và chú ý là phải đúng cả tên và phần mở rộng. 
Nếu như cái file của mình và cái file Python nó không cùng thư mục thì chúng ta sẽ cần phải thêm vào cái đường dẫn. Ở đây thì tôi để cùng thư mục cho nên chúng ta sẽ không cần cái đường dẫn. Như vậy thì với cái dòng này chúng ta tải được một cái game vào trong cái biến image. 
Tiếp theo để hiển thị lên thì chúng ta sẽ vào trong cái vòng lặp game và trước khi update chúng ta sẽ thực hiện vẽ cái hình ảnh đó ra màn hình. Chúng ta sẽ vẽ hình ảnh ra cửa sổ để vẽ thì chúng ta sử dụng screen, screen là cái màn hình của mình và thực hiện cái phương thức blit. 
Ở đây chúng ta sẽ cần thứ nhất cung cấp biến image biến này chúng ta đã load hình ảnh vào và cái thứ 2 chúng ta sẽ cung cấp vị trí của hình ảnh mà nó hiển thị. Ví dụ đây, tôi để là vị trí 100, 100 rồi bây giờ chúng ta hãy xem là khi phần mềm nó chạy nó sẽ hiển thị như thế nào. Python pygame.py đây chúng ta sẽ thấy là sau khi nó vẽ những cái đường tròn thì có một cái hình ảnh nó đè lên trên và cái vị trí của nó là 100, 100, có nghĩa là nó cách cái góc trên bên trái là 100 pixels về bên trái và 100 pixels từ trên xuống là như thế này. Nếu như chúng ta muốn chuyển nó vào giữa thì chúng ta phải tính toán cái kích thước của nó làm sao cho nó vào giữa. Khi mà chúng ta thực hiện hiển thị một hình ảnh lên trên cái cửa sổ như thế này chúng ta phải biết được: thứ nhất là kích thước của hình ảnh, thứ hai là cái kích thước, thứ hai là cái vị trí để chúng ta đặt cái hình này để lên cửa sổ đúng đắn. Ví dụ ở đây giả sử tôi đổi lên thành 275, 275 và chạy lại Python mygame.py thì chúng ta thấy là cái hình của chúng ta đã được vào giữa. Cái việc mà tính toán như thế nào thì chúng ta sẽ dựa vào kích thước của này chia đôi và trừ đi cái kích thước chiều ngang và chúng ta sẽ thực hiện tính toán nhiều hơn khi chúng ta đi vào cái project của mình. Ở đây thì tôi chỉ hướng dẫn các bạn đó là hiển thị một cái hình ảnh lên trên cái cửa sổ mà thôi.
## Section 4: Project: Game băng qua đường
### Subsection 4.1: Project: Game băng qua đường
Chúng ta đã hoàn thành xong phần thứ hai đó là giới thiệu Pygame, bây giờ chúng ta sẽ qua phần thứ ba đó là làm một cái project liên quan đến bài game này. 
Thì các bạn nhìn trên đây chúng ta sẽ thấy đây là một game hoàn chỉnh của mình, một game dạng băng qua đường: có một nhân vật game, thì ở đây chúng ta sẽ được điều khiển nhân vật này đi tới và đi lui. Đây chúng ta sẽ được điều khiển đi tới đi lui thôi. Có một cái nhân vật thù địch cho chúng ta gọi là enemy và nhân vật này nó sẽ di chuyển trái phải như thế này. Khi chúng ta vượt qua các chướng ngại vật và chạm đến hộp kho báu thì chúng ta sẽ được thông báo là You win. Khi mà You win thì chúng ta sẽ lên một cái vòng mới và nhân vật này nó sẽ nhanh hơn các nhân vật thù địch nó sẽ chuyển động nhanh hơn và chúng ta sẽ được những vòng mới như này. Sau đó thì nếu như mà chúng ta qua vài vòng chúng ta thấy là nó sẽ xuất hiện thêm nhân vật thứ hai và nhân vật thứ ba nếu chúng ta lên cao nữa.
Thì đây là một cái game cơ bản để chúng ta ứng dụng cái Pygame xây dựng một cái project hoàn chỉnh. Nó bao gồm một hình nền đưa lên những nhân vật game, nhân vật không điều khiển được và một cái gameobject đó là một kho báu. Chúng ta sẽ cùng nhau thực hiện cái project này thông qua những bài học ở trong phần này.
Tiếp theo thì tôi xin giới thiệu cho các bạn về cách để thiết lập display và những thông số khi mà chúng ta bắt đầu thực hiện game.
Để bắt đầu xây dựng project của mình thì chúng ta sẽ tạo một cái file mới đó là mygame.py và chúng ta sẽ thiết lập lại từ đầu. Ở trong cái project này hiện tại chúng ta có một cái background.png đây một cái background như thế này. Và để ôn tập lại cái phần đầu tiên đó là lập trình hướng đối tượng do đó thì chúng ta sẽ thiết kế game dưới dạng lập trình hướng đối tượng. Chúng ta sẽ tạo một cái class game và sau đó chúng ta cho phép là chạy trên cái class này. 
Rồi đầu tiên chúng ta sẽ import pygame như bình thường. Sau đó thì đến thiết lập các màn hình thiết lập những thông số màn hình thì chúng ta sẽ có screen width, screen height chúng ta sẽ để là screen title, đây là cái phần đây là tiêu đề của cái cửa sổ chúng ta sẽ để làm mygame các bạn hoàn toàn có thể tùy chỉnh như thông số này. Tiếp theo chúng ta sẽ để là screen width 800 và screen height tương ứng 800. Sau đó chúng ta sẽ định nghĩa tiếp 2 cái màu cơ bản, 2 màu này nó là màu trắng và màu đen ở đây chúng ta định nghĩa thành một cái tên nào đó để gọi cho nó đơn giản hơn. White color, thì white color này nó sẽ gồm ba thông số đó là 255, 255, 255. Black color thì ba thông số của nó là 0, 0 và 0. Cái thứ ba mà chúng ta cần đó là cái đồng hồ - Clock thì đây chúng ta sẽ gọi clock bằng pygame chấm time chấm clock. 
Như vậy thì chúng ta đã hoàn thành cái việc thiết lập những thông số cơ bản của trò chơi của mình thì bây giờ chúng ta sẽ thiết lập OOP hay nó khác là lập trình hướng đối tượng bằng cách là tạo một class game. 
Class Game 2 chấm (:) trong class game này chúng ta sẽ định nghĩa một cái thông số đó là Tick Rate các bạn có thể định nghĩa là FPS cũng được. Đây chúng ta định nghĩa là 60 ở đây chính là cái thông số FBS frames-per-second của mình.
Hàm khởi tạo. Trong hàm khởi tạo này thì chúng ta sẽ cần một số thông số: thứ nhất là self cái này đương nhiên, sau đó đến các image_path, image_path này chúng ta sẽ đưa thông tin của background vào đến title, width và height. Trong đây thì chúng ta cực kỳ đơn giản thôi chúng ta sử dụng self chấm thuộc tính nào đó. 
Self chấm title bằng title. Tương tự self chấm width bằng width, self chấm height bằng height. Như vậy chúng ta lưu lại những cái thông tin cơ bản của cái display của mình nó bao gồm title, width và height. Và ở đây chúng ta cũng thiết lập luôn cái màn hình game của mình.
Màn hình game thì chúng ta sẽ sử dụng một cái biến để lưu và lưu ở trong các class game luôn. Như vậy thì self chấm game screen, thay vì chúng ta tạo một cái biến toàn cục bên ngoài thì chúng ta tạo trở thành một cái thuộc tính của các class game và có thể sử dụng về sau. Bằng pygame.display.set_mode.
Tất cả những hàm này thì chúng ta đã học trong cái phần giới thiệu liên quan đến Pygame ở đây chúng ta sẽ để là width và height.
Rồi sau đó thì chúng ta sẽ tô màu màn hình: self chấm game screen chấm fill và giả sử cái hình nền chúng ta muốn chọn là màu trắng. White color chúng ta sẽ tô bằng cái màu trắng vào đây. Và thực hiện đưa cái title của mình lên cái cửa sổ là self chấm game srceen chấm set caption.
Và đưa cái title của mình lên trên cái cửa sổ bằng lệnh là pygame chấm display chấm set caption, thông số đầu vào đó là title.
Việc tiếp theo thì chúng ta sẽ thiết lập đến hình nền. Hình nền chúng ta kèm theo đó là background.png, như vậy chúng ta sẽ load cái hình nền này và sau đó vẽ hình nền này lên trên cửa sổ. Như vậy đầu tiên chúng ta phải load được cái hình nền.
Thiết lập hình nền, ta sẽ lưu vào một cái biến đó là background_image pygame chấm image chấm load, điền vào đây thông số đó là image_path và lưu cái này vào trong một cái thuộc tính là image. Ở đây chúng ta sử dụng thêm một cái hàm đó là scale để chỉnh cái kích thước màn hình đúng như kích thước mà chúng ta mong muốn bởi vì cái ảnh của chúng ta có thể là nó không đúng kích thước chúng ta mong muốn cái kích thước của màn hình hiện tại đó là 800x800 tuy nhiên cái background.png thì nó không phải có độ phân giải tương ứng do đó thì chúng ta sử dụng scale để chỉnh lại cái kích thước hình ảnh. Rồi ở đây chúng ta sử dụng là pygame chấm transform chấm scale đưa vào đây đó là background_image và chỉnh về đúng cái kích thước width và height tương ứng có nghĩa là 800 và 800.
Rồi như vậy thì chúng ta đã hoàn thành cái hàm khởi tạo và tiếp theo chúng ta cần hoàn thành đó là cái game loop. Def run_game_loop đây, chúng ta định nghĩa nên một cái phương thức là run game loop. Ở đây chúng ta thực hiện chạy cái vòng lặp game trong các class game này. Ở đây có self. Chúng ta sử dụng một biến đó là is_game_over và hiện tại chúng ta khởi tạo với giá trị là False. Khi mà cái game chưa bị over tức là not game over thì cái vòng lặp game vẫn còn chạy, đây chúng ta sẽ để là while not is game over. Và tương tự chúng ta sẽ có một cái vòng lặp for chạy qua các event. Đây ta có thể copy cái project lần trước copy vào đây. For event in pygame chấm event chấm get. If event type bằng với pygame chấm quit thì cái game over này là chúng ta cho nó là True. Khi đó cái vòng lặp game nó sẽ dừng lại. 
Trong vòng lặp game thì chúng ta sẽ cần vẽ lại màn hình. Hiện tại thì chúng ta chỉ có một cái hình ảnh đó là cái background.png sau đó chúng ta sẽ load hình ảnh lên. 
chúng ta sẽ sử dụng là self chấm game screen chấm click để load hình ảnh thì trong đây chúng ta sẽ để là self chấm image và cái vị trí của hình ảnh này là 0, 0, tức là hình ảnh ta sẽ load đè lên toàn bộ màn hình, đương nhiên là trước đó thì chúng ta cũng nên fill lại cái màn hình một cái self chấm game_screen chấm fill. Chúng ta sẽ để lại cái white color của mình tức là hình nền vẫn là white color và sau đó chúng ta vẽ một cái background lên trên màn hình.
Phần tiếp theo thì đừng quên cái lệnh update, ta gọi đến pygame chấm display chấm update và cuối cùng đó là clock chấm tick và đưa vào đây đó là thông số tick rate mình đã định nghĩa ở trên.
Rồi như vậy chúng ta đã hoàn thành xong một cái class game và với class này thì chúng ta có thể run cái game của mình.
Đương nhiên thì chỉ với class thì chúng ta chưa chạy được chương trình do đó chúng ta cần những cái đoạn code bên ngoài đó là chạy cái chương trình chính. Chúng ta sẽ viết cái chương trình chính ở đây. 
Trong chương trình chính đương nhiên chúng ta sẽ có pygame chấm init để khởi tạo pygame. Sau đó chúng ta sẽ sử dụng một cái object new game. Đây là một đối tượng từ cái class game của mình do đó game và mở ngoặc ra đưa vào các thông số cần thiết: thứ nhất là cái image_path thì đây là cái background của mình, cái background thì tôi đã kèm theo trong cái project đó là background.png; và title, title thì chúng ta đã có thông số đó là screen title; width thì chúng ta có screen width; và height chúng ta đã có screen height. Như vậy chúng ta đã khởi tạo được một cái đối tượng liên quan đến cái class game. Để chạy thì chúng ta sẽ gọi một cái phương thức đó là new game chấm run_game_loop thì dòng này sẽ giúp chúng ta chạy một cái phương thức đó là run game loop và nó sẽ chạy chúng ta cái vòng lặp game.
Cuối cùng sau khi kết thúc vòng lặp game chúng ta sẽ có một cái pygame chấm quit để đóng cái gối pygame lại. Đóng cái pygame engine. Rồi như vậy chúng ta đã hoàn thành xong cái phần tạo ra cái class game hay nói khác là chúng ta thiết lập cái OOP, thiết lập cái lập trình hướng đối tượng cho cái pygame của mình. Bây giờ chúng ta sẽ chạy thử để xem là kết quả như thế nào. Python mygame.py. Kết quả như mong đợi đó là hiển thị lên một cái cửa sổ game và cái background chúng ta chiếm đầy cửa sổ. Đây chúng ta thấy hiện tại là kết quả chúng ta là có một cái cửa sổ 800, 800, một cái background hiển thị lên chiếm đầy cửa sổ như thế này và cái title ở đây đó là mygame rồi. Như vậy thì chúng ta đã hoàn thành được một cái vấn đề rất hay đó là tạo cái lập trình hướng đối tượng cho cái pygame. 
Tiếp theo chúng ta sẽ đưa các đối tượng game lên màn hình bởi vì trong lập trình hướng đối tượng do đó chúng ta sẽ tiếp tục tạo một class mới. Chúng ta sẽ tạo một cái class gọi là GameObject đây là class tổng quát dành cho các đối tượng trong game. Class tổng quát: class GameObject. Đương nhiên chúng ta sẽ cần một cái hàm khởi tạo. Đối với một đối tượng game, thì một đối tượng game thực chất đó là một cái hình ảnh bên ngoài và chúng ta đưa vào trong game của mình như vậy chúng ta sẽ cần: thứ nhất là image_path đường dẫn đến cái image, cái thứ hai chúng ta cần vị trí x và y và cái thứ ba chúng ta phải biết được rằng là cái kích thước của nó, thì đây chúng ta sẽ cần width và height. Như vậy thì một đối tượng game chúng ta sẽ có một số thông số như sau: đường dẫn đến hình ảnh, vị trí đặt và kích thước. Rồi chúng ta sẽ lưu lại bằng những cái thuộc tính ở trong cái class này. Trước hết chúng ta sẽ load image lên object_image pygame chấm image chấm load, load bằng image_path. Rồi sau khi load xong chúng ta sẽ sử dụng self chấm các thuộc tính và lưu lại tất cả. Self chấm image bằng pygame chấm transform, chúng ta sẽ thực hiện một cái đó là scale nó lại, scale object image với cái kích thước mới đó là width và height. Và chúng ta cũng cần lưu lại cái vị trí x, vị trí y và cái chiều rộng, chiều cao của đối tượng. Như vậy đây chúng ta sẽ có self.x_pos bằng x, self.y_pos bằng y, self.width bằng width và cuối cùng self.height bằng height.
Trước khi mà kết thúc cái phần cải tạo thì chúng ta thực hiện một lệnh nữa, đó là vẽ ra màn hình.
Như vậy thì chúng ta đã xong cái phần khởi tạo ở đây và chúng ta sẽ cần một cái hàm đó là một cái phương thức vẽ đối tượng này ra màn hình. Ta sẽ tạo một cái hàm mới. Def draw. Hàm này thì chúng ta thứ nhất để vào đây self và cái thứ hai là để một cái background, chúng ta có thể hiểu cái ngữ cảnh của cái background này background này không phải là hình nền mà là một cái service hoặc là một cái screen và chúng ta sẽ truyền cái screen của cái game vào đây. Rồi như vậy ở đây chúng ta sẽ để là background chấm blit này sử dụng cái hàm blit trong pygame để chúng ta đưa ra self chấm image đặt cái image này tại cái vị trí là x_pos và y_pos. Self chấm x_pos và self chấm y_pos. Như vậy thì tạm thời chúng ta hoàn tất cái GameObject của mình: thứ nhất khởi tạo đưa tất cả những thông số và lưu lại, cái thứ hai chúng ta có một cái phương thức đó là vẽ cái đối tượng này lên trên cái màn hình game của mình. 
Rồi bây giờ chúng ta sẽ áp dụng cái class GameObject này để bắt đầu vẽ một cái kho báu, đây là một cái hộp kho báu thì hộp kho báu tôi kèm theo bằng một cái file đó là treasure.png - cái hộp kho báu như thế này và chúng ta sẽ vẽ cái hộp này lên trên cái game của mình. Và cái vị trí vẽ thì chúng ta sẽ đặt cái hộp kho báu tại đây. Chúng ta sẽ đặt cái hộp kho báu ngay tại cái chỗ này và khi người chơi có thể vượt qua tất cả các chướng ngại vật chạm đến cái hộp kho báu thì sẽ chiến thắng.
Bây giờ trong cái phần class game vào cái vòng lặp game. Chúng ta sẽ khởi tạo cái hộp kho báu. Khởi tạo đối tượng hộp kho báu. Khởi tạo đối tượng thì: thứ nhất cần một cái biến chúng ta ghi là treasure và đối tượng game, gọi đến các class GameObject trong đây chúng ta sẽ đưa vào image là treasure.png, vị trí, rồi tạm thời thì chúng ta sẽ để là 0, 0và kích thước thì chúng ta sẽ cho nó kích thước là 50 và 50. Trong phần vòng lặp game, Trong vòng lặp for ở đây, Trong vòng lặp while ở đây, ta sẽ vẽ nó ra. Đương nhiên là phải trước update, vẽ hộp kho báu, treasure chấm draw, phương thức draw đó là phương thức ở trong cái GameObject class mở ngoặc đóng ngoặc. 
Tiếp theo chúng ta sẽ xây dựng nhân vật game. 
Nhân vật game là một GameObject do đó chúng ta có thể xây dựng một cái class con của class GameObject ở đây. Chúng ta sẽ xây dựng class cho nhân vật game. Class đã đặt tên là PlayerCharacter mở ngoặc (() và đưa vào đây GameObject, có nghĩa là PlayerCharacter đó là một lớp con của cái lớp GameObject. Trong đây, chúng ta cần một cái thông số đặc biệt đó là tốc độ di chuyển, bởi vì cái hộp kho báu nó không di chuyển do đó chúng ta không cần do đó chúng ta sẽ không cần đến cái tốc độ di chuyển, tuy nhiên thì nhân vật game phải di chuyển do đó chúng ta sẽ cần một cái thông số đó là tốc độ di chuyển. Và đây chúng ta đặt SPEED, là 10, tạm thời chúng ta sẽ đạt tốc độ là 10. 
Tiếp đến là hàm khởi tạo. Trong hàm khởi tạo thì tương tự chúng ta sẽ có một cái là self, một cái là image_path, vị trí x, vị trí y và chiều rộng, chiều cao. Ta sẽ thấy là các thông số nó tương tự như các GameObject. Trong đây thay vì chúng ta thực hiện lại tất cả những dòng như thế này chúng ta có thể gọi chúng ta có thể gọi lại hàm khởi tạo của lớp cha của nó. Để gọi chúng ta sử dụng một hàm đó là super().__init__. Với cái từ super này thì hàm khởi tạo của các PlayerCharacter nó sẽ gọi lại cái hàm khởi tạo của cái GameObject, do đó thì trong đây chúng ta sẽ cần tất cả những thông số cần thiết. Image_path, x, y, width và height.
Và chúng ta sẽ đưa vào.
Như vậy chúng ta đã hoàn thành cái hàm khởi tạo và tiếp theo chúng ta sẽ có một cái hàm đó là move, bởi vì nhân vật game thì có thể di chuyển, do đó chúng ta cần cái hàm này. Trong một hàm chúng ta sẽ cần self, di chuyển thì sẽ có hai hướng lên và xuống cho nhân vật game chỉ có thể đi lên đi xuống mà thôi và đây chúng ta sẽ có một cái là direction để quy định là nhân vật game ta đang đi lên hay đi xuống. Rồi ở đây chúng ta sẽ chú thích vào. 
Ta sẽ quy định rằng khi mà direction lớn hơn không thì nhân vật của chúng ta sẽ đi lên ngược lại thì sẽ đi xuống.
Việc thực hiện di chuyển cho nhân vật game thì cực kỳ đơn giản thôi, nếu như cái direction mà lớn hơn 0, thì mỗi lần một vòng lập game chạy thì chúng ta sẽ cập nhật cái vị trí của cái nhân vật game này lại, tức là cái self.y_pos có thể là giảm đi, đi lên thì sẽ giảm. Và nếu như cái direction này nó âm thì chúng ta sẽ cập nhật lại mỗi lần chúng ta sẽ cộng thêm. Cực kỳ đơn giản thôi. Đây if direction mà lớn hơn 0, thì mỗi lần cái vòng lập game nó chạy chúng ta sẽ cập nhật bằng cách là sử dụng self.y_pos trừ bằng self.SPEED. Các bạn hình dung cái cửa sổ game thì càng lên trên cái vị trí y nó càng giảm, do đó khi nhân vật đi lên có nghĩa là cái vị trí y chúng ta phải trừ đi. Rồi tương tự elif, ngược lại đối với trường hợp direction là nhỏ hơn 0, ở đây chúng ta sẽ phải để là elif để kiểm tra cái direction nhỏ hơn 0, nhỏ hơn 0. Đối với trường hợp direction bằng 0 thì nhân vật chúng ta nó sẽ đứng yên, đây elf.y_pos sẽ là cộng bằng self.SPEED. 
Rồi như vậy thì cái logic của di chuyển trong các nhân vật game cực kỳ đơn giản như thế này.
Bây giờ chúng ta sẽ thử khởi tạo một nhân vật game và cho các nhân vật này di chuyển. Quay trở về cái hàm run_game_loop, thì ở đây chúng ta sẽ khởi tạo một cái biến direction để quy định cái chiều hướng di chuyển của nhân vật game. Trước mắt chúng ta sẽ cho cái direction này bằng 0. Sau đó khởi tạo nhân vật game PlayerCharacter, gọi đến class player_character, image của mình thì chúng ta sẽ sử dụng là player.png. Những cái file hình ảnh thì tôi có kèm theo trong cái đường link để các bạn có thể download cái hình ảnh này về. Rồi vị trí x ở đây chúng ta sẽ có vị trí 0, 0 và kích thước là 50 và 50. 
Bây giờ chúng ta sẽ định vị trí cho cái player_character này. Thứ nhất vị trí phải ở giữa tương ứng với cái hộp kho báu như vậy vị trí là 375. Vị trí theo trục y, thì ở đây chúng ta nhớ rằng là cái chiều cao của màn hình là 800 như vậy thì vị trí chúng ta có thể đạt một con số nào đó ví dụ như là 700 tức là ít nhất là nó không rời khỏi màn hình. 
Bây giờ chúng ta sẽ xử lý một cái vấn đề đó là sự kiện người dùng nhấn vào một cái nút nào đó. Như vậy thì sự kiện thì chúng ta phải đưa vào trong cái vòng lặp for thì vòng lặp for này kiểm tra tất cả những sự kiện xảy ra trong cái game của mình. Vậy đây sau khi kiểm tra cái sự kiện width chúng ta sẽ kiểm tra thêm những sự kiện khác. Rồi ở đây sẽ có một cái elif. Đầu tiên chúng ta sẽ kiểm tra là event.type bằng pygame.KEYDOWN, sự kiện này phát sinh khi có một nút nào đó trên bàn phím được nhấn xuống. Khi có một nút nào được nhấn thì bắt đầu chúng ta sẽ kiểm tra xem nút đó là nút gì, nếu như cái event.key bằng với lại là pygame.K_UP có nghĩa là cái nút mũi tên lên. Nếu như mũi tên lên được nhấn thì đơn giản chúng ta sẽ xét cái direction này là một để cho nhân vật game có thể đi lên. Elif, ngược lại nếu cái key mà được nhấn là pygame.KEYDOWN thì direction của mình chúng ta sẽ gán cho một giá trị âm, đó là - 1. Đây chúng ta sẽ kết thúc cái sự kiện KEYDOWN, có nghĩa là một nút nào đó được nhấn. Tuy nhiên thì nhấn xong thì phải bỏ ra tức là chúng ta sẽ có một sự kiện là KEYUP. Đây elif event.type, ta sẽ kiểm tra tiếp một cái sự kiện đó là pygame.KEYUP, có nghĩa là hết nhấn rồi chúng ta buông cái nút ra thì sự kiện KEYUP sẽ phát sinh. Nếu như là hiện tại một cái phím K_DOWN hoặc là một phím K_UP nào đó nó được nhấn và hiện tại được buông ra thì các direction của mình sẽ được xét trở lại là 0. Tức là event.key là K_UP hoặc event.key là K_DOWN thì lúc này cái direction của chúng ta sẽ quay về 0, hay nói khác là nhân vật game sẽ ngừng di chuyển.
Rồi bây giờ cũng trong cái vòng lặp game sau khi chúng ta vẽ màn hình, vẽ hộp kho báu thì đây chúng ta sẽ vẽ nhân vật game của mình ra. Vẽ player_character.draw trên cái self.game_screen. Tuy nhiên trước khi vẽ thì chúng ta sẽ cho cây player_character này di chuyển một cái đoạn đó là SPEED sau đó chúng ta mới vẽ. player_character.move di chuyển với cái direction mà chúng ta nãy giờ chúng ta đang thực hiện với nó. Rồi bây giờ chúng ta sẽ cho chạy thử.
Tuy nhiên hiện tại thì chúng ta chưa có cái file đó là player.png. Bây giờ chúng ta sẽ download cái file này về.
Xoá 1:33:54 - 1:34:43
Rồi như vậy thì chúng ta có một cái file đó là player.png, đây một cái nhân vật như thế này và chúng ta sẽ đưa cái nhân vật này lên trên game của mình. Save lại và chạy thử cái game đây chúng ta thấy là nhân vật game đã xuất hiện trên màn hình và chúng ta có thể sử dụng cái nút tới và lui bằng cách là bấm cái nút mũi tên lên và mũi tên xuống để điều khiển nhân vật game.
Tuy nhiên thì có một cái vấn đề phát sinh ở đây, có nghĩa là đó là khi cái nhân vật game này nó di chuyển ra khỏi cái màn hình bên dưới này đây do không có kiểm tra do đó thì cái nhân vật của mình nó đi luôn và không quay lại. Chính vì vậy mà chúng ta cần phải có một cái điều kiện kiểm tra để cho nhân vật không thể di chuyển ra khỏi cái màn hình. Ở trên này thì không cần bởi vì chúng ta sẽ có một cái kiểm tra sau, đó là khi mà nhân vật game chạm vào cái kho báu thì cái game của mình sẽ kết thúc. Như vậy thì chúng ta sẽ cần một cái kiểm tra bên dưới để nhân vật game không thể ra khỏi màn hình. Quay lại cái code của mình và quay lại cái PlayerCharacter. Trong cái phần move, thì đây chúng ta sẽ cần một cái điều kiện để đảm bảo nhân vật không di chuyển vượt khỏi màn hình bên dưới. Như vậy thì ở đây chúng ta sẽ có kiểm tra if self.y_pos mà lớn hơn hoặc bằng một cái thông số nào đó, một cái height của cái màn hình và chúng ta sẽ đưa cái thông số vào đây để cho dễ quản lý. Max_height, nếu như cái self.y_pos này mà nó vượt qua cái max_height có nghĩa là nó đi quá lố, thì đây để tránh trường hợp mà nó mất cái nhân vật game cho nó, chúng ta sẽ trừ thêm một cái đoạn là 50 hoặc là 40. Nếu như vừa quá thì chúng ta sẽ gán lại self.y_pos sẽ bằng cái này bằng cái max_height - 40, có nghĩa là nếu lớn hơn thì chúng ta sẽ gán lại cái này lớn hơn thì chúng ta lại tiếp tục gán lại cái này. Do đó thì nhân vật game không thể nào mà có cái vị trí y_pos nó lớn hơn được cái này. Rồi ở đây do cái move này chúng ta có là cái direction và cái max_height tức là có hai thông số do đó phía dưới này chúng ta cũng cần thay đổi. 
Cái phương thức move chúng ta sẽ đưa vào self.height rồi kiểm tra lại lần nữa đây chúng ta thấy nhân vật game đã xuất hiện và vẫn di chuyển được bình thường. Tuy nhiên bây giờ chúng ta cho nó xuống ở bên dưới thì rõ ràng không thể nào vượt khỏi cái màn hình bởi vì chúng ta đã chặn cái điều kiện ở đây.
Như vậy thì chúng ta đã tạo được một cái Class PlayerCharacter và hiển thị được một cái nhân vật game ra màn hình, chúng ta cũng thêm vào một sự kiện đó là bắt được cái việc mà người dùng nhấn vào cái nút mũi tên lên và xuống, kiểm tra được nhân vật game không thể chạy vượt khỏi cái màn hình của mình.
Tiếp theo thì chúng ta sẽ xây dựng những đối tượng quân thù chúng ta gọi là NPC. 
Rồi ở đây thì tương tự như cái Class PlayerCharacter, chúng ta sẽ tạo một cái Class NonPlayerCharacter. 
Class cho các NPC thì chúng ta có thể gọi đó là enemy. Một số con quái vật chẳng hạn. Rồi ở đây chúng ta sẽ có Class NonPlayerCharacter, đây chúng ta chép cái này xuống và đương nhiên nó cũng là một cái lớp con của cái lớp GameObject. Tương tự như là player thì các monster hay các enemy này cũng có thể di chuyển do đó chúng ta cũng có một cái thông số đó là tốc độ di chuyển. Cái thứ hai là hàm khởi tạo thì hàm khởi tạo chúng ta có thể copy từ cái PlayerCharacter này bởi vì hàm khởi tạo nó cũng tương tự nên chúng ta thấy nó cũng có cần image_path nè, x, y nè, width và height. Và cũng lấy từ cái hàm khởi tạo của cái GameObject, chúng ta gọi đến cái super. Chúng ta sẽ copy ở đây.
Tiếp theo là cái phương thức là move, chúng ta sẽ gọi def move trong đây thì có self và max_width. Ở đây hàm move nó sẽ khác với cái hàm move của cái nhân vật player bởi vì player này nó cần cái direction, chúng ta sẽ điều khiển nhân vật đi lên và đi xuống do đó chúng ta cần đến direction, trong khi các enemy này chúng ta không điều khiển được các nhân vật này nó sẽ tự động di chuyển từ trái qua phải và khi chạm cái biên nó sẽ di chuyển ngược trở lại. Do đó thì chúng ta sẽ không cần đến direction này. Rồi ở đây chúng ta sẽ cho các nhân vật nó thực hiện di chuyển theo một cái logic như sau: if, nếu như cái vị trí x_pos của nó mà nhỏ hơn bằng 0, thì chúng ta sẽ cho cái SPEED cập nhật lại, SPEED nó sẽ được cập nhật lại bằng abs của cái SPEED. 
Có nghĩa là khi SPEED đang mang giá trị âm nó làm cho cái x_pos càng ngày càng giảm dần và khi nó vượt đến biên có nghĩa là nó nhỏ hơn 0 thì chúng ta sẽ cập nhật các SPEED này lại thành dương để cho nó cộng vào cái x_pos này nó tăng cái x_pos này lên.
Xóa 1:41:46 - 1:41:57
Cái kiểm tra thứ hai là nếu như cái x_pos nó vượt quá cái bên phải màn hình, x_pos lớn hơn và bằng cái max_width. Đương nhiên nếu như ta để cái max_width này thì nó vượt luôn khỏi cái màn hình thì nó không ổn, do đó chúng ta sẽ trừ đi cái width của cái nhân vật, thì cái width của nhân vật chúng ta là khoảng 50 thì chúng ta sẽ trừ 40 là ổn. Rồi ở đây chúng ta sẽ tiếp tục cập nhật lại self.SPEED bằng trừ abs của self.SPEED. Hàm abs hàm abs sẽ trả về giá trị tuyệt đối do đó do đó trừ abs chắc chắn chúng ta sẽ được giá trị là âm. Rồi và cuối cùng chúng ta sẽ cập nhật lại vị trí của x_pos dựa trên cái SPEED này bằng cách là gọi self.x_pos cộng bằng self.SPEED. 
Chúng ta có thể thảo luận lại cái hàm move như sau: cái dòng chính của cái hàm move này đó là self.x_pos cộng bằng self.SPEED. 
Như vậy thì nhân vật như vậy thì các enemy của chúng ta, cái vị trí x_pos nè luôn luôn được cộng cho cái self.SPEED này và nó đi từ trái qua phải trước tiên, sau đó nếu như chạm vào cái biên bên phải hay nó khác là cái vị trí pos nó lớn hơn cái max_width - 40 thì cái SPEED này nó trở thành âm bằng cách bằng cách là chúng ta sử dụng trừ abs của cái self.SPEED, khi đó các enemy nó sẽ di chuyển ngược trở lại từ phải sang trái cho đến khi nó chạm vào biên. 
Đó là cái điều kiện seo chấm xbox nhỏ hơn bằng không nó 
Đó là cái điều kiện self.x_pos nhỏ hơn bằng 0 nó đúng thì lúc đó cái SPEED này nó sẽ trở thành dương trở lại và nó di chuyển ngược từ trái qua phải và cứ lặp đi lặp lại như vậy. Mỗi vòng lặp game thì nó sẽ cập nhật lại cái vị trí cho chúng ta.
Rồi bây giờ chúng ta sẽ khởi tạo các cái nhân vật của mình. Sau cái phần khởi tạo player thì chúng ta sẽ tiếp tục khởi tạo các enemy. Giả sử thì tôi có ba cái enemy, đây enemy_0 gọi đến NonPlayerCharacter và ba cái enemy này sử dụng chung một cái hình thôi đó là hình enemy.png. Các vị trí thì chúng ta sẽ sắp xếp vị trí thứ nhất là 20, vị trí ở đây thì nó cũng không quan trọng cho lắm cái vị trí mà x không quan trọng cho lắm bởi vì nhân vật này nó sẽ tự di chuyển, do đó chúng ta cứ để hai mươi rồi sau đó 600, kích thước 50, 50 như là cái hộp kho báu và cái nhân vật game của mình là những cái này kích thước sẽ giống nhau. 
Rồi tiếp tục chúng ta sẽ khởi tạo cái enemy_1 và enemy_2. Rồi chúng ta sẽ copy ra và chỉnh lại kích thước và chỉnh lại cái vị trí chút xíu. Ví dụ đây chúng ta cho nó khoảng là self.width - 40 tức là nó gần sát bên cái màn hình rồi cái này thì chúng ta sẽ cho nó là 400, là khoảng ở giữa. Đối với vị trí y thì cái này là 600, cái này ta sẽ giảm lại sẽ là 400 và cái này khoảng là 200. Như vậy chúng ta đã khởi tạo được các enemy.
Tiếp theo chúng ta phải cập nhật vị trí và vẽ các enemy ra tương tự như các nhân vật game. 
Đây chúng ta sẽ gọi enemy_0.move cho nó di chuyển và truyền vào cái max_width đó là self.width, sau đó vẽ ra enemy_0.draw và truyền vào game_screen. Tương tự đối với enemy_1 và 2 thì đây chúng ta sẽ copy cái này, 1 nè, 2 nè. 1, 2.
Rồi chúng ta thấy là nó đang bị undefile, chúng ta sẽ xem lại ở trên. Rồi ở đây chúng ta quên sửa cái này ha enemy này là 1 và enemy này là 2. 
Như vậy thì chúng ta đã thực hiện xong một số cái vấn đề liên quan đến enemy. Bây giờ chúng ta sẽ test thử trên cái game của mình. Chạy ứng dụng Python mygame.py. Rồi chúng ta sẽ thấy nhân vật game chúng ta đứng ở đây, các quân thù địch thì nó sẽ di chuyển qua lại trên màn hình và rõ ràng thì chúng ta thấy là khi nó chạm vào cái biên bên trái nè thì nó sẽ di chuyển ngược lại và nó chạm vào biên bên phải thì nó sẽ di chuyển từ phải qua trái ngược lại. Khi nhân vật chúng ta có nhiệm vụ là phải vượt qua các chuyến hệ vật này và đi đến được họp kho báu, đương nhiên hiện tại thì khi mà nó chạm vào các enemy thì không có gì xảy ra do đó chúng ta cần phải tiếp tục kiểm tra những cái va chạm này, nếu như thực hiện va chạm đến các enemy thì chúng ta sẽ hiện lên những dòng chữ Gameover chẳng hạn. Còn nếu như chạm vào được cái hộp kho báu và vượt qua được hết các enemy này thì nó sẽ hiện lên những cái thông báo ví dụ như là You win. 
Như vậy thì trong phần này chúng ta đã tạo được một cái NonPlayerCharacter Class để hiển thị những cái đối tượng quân thù - những cái enemy lên trên cái game của mình. 
Như chúng ta đã biết hiện tại chúng ta đã đưa được các nhân vật lên trên màn hình như thế này. Tuy nhiên thì khi va chạm nhau thì không có gì xảy ra do đó thì tiếp theo chúng ta bắt buộc phải có một cái chức năng đó là kiểm tra các va chạm. Và rõ ràng chúng ta thấy rằng á là chỉ có cái nhân vật game va chạm với các enemy hoặc là nhân vật game va chạm với cái hộp kho báu này, do đó thì sẽ không bao giờ có cái trường hợp là các enemy của mình va chạm được với cái hộp kho báu, do đó thì cái hàm kiểm tra va chạm chúng ta sẽ đưa vào trong cái class của PlayerCharacter. Đây sau hàm move thì chúng ta sẽ tạo một cái hàm mới đó là hàm kiểm tra va chạm, ta gọi là detect_collision. Trong đây thì chúng ta sẽ có self và đưa vào đây một cái other_body hay nói cách khác là hàm này nó sẽ trả về là True hoặc là False. Nếu là True có nghĩa là cái PlayerCharacter của mình hiện tại đang va chạm với cái other_body này. Ngược lại trả về False có nghĩa là không va chạm. Rồi ở đây chúng ta sẽ return ra là True tức là mặc định nó sẽ là có va chạm. Tuy nhiên sẽ có một số trường hợp không va chạm chúng ta sẽ kiểm tra và trả về False nếu như nó thuộc về các trường hợp đó. 
Bây giờ chúng ta sẽ có một số trường hợp như sau: thứ nhất là cái vị trí y của cái player nó lớn hơn cái vị trí y của cái other_body và cộng thêm cái height.
Nói cách khác giả sử là cái PlayerCharacter nó đang ở phía dưới này và cái other_body nó ở giữa như thế này thì chúng ta thấy là cái y này nó lớn hơn hẳn hoàn toàn so với cái other_body thì không bao giờ nó va chạm được, do đó lúc này chúng ta sẽ trả về False. Trong trường hợp này có nghĩa là if self của cái y_pos tức là vị trí y mà nó lớn hơn hẳn của cái other_body.y_pos cộng với other_body.height thì chúng ta sẽ return là False.
Trường hợp thứ hai, nếu cái player của chúng ta có cái vị trí y mà cộng thêm với cái chiều cao của nó nữa mà vẫn nhỏ hơn các other_body.y_pos thì lúc này cũng không thể va chạm dưới đây ta có self.y_pos và cộng thêm self.height mà vẫn nhỏ hơn other_body.y_pos, trường hợp này cũng không thể nào xảy ra va chạm, như vậy đây chúng ta sẽ return là False.
Tương tự chúng ta có hai trường hợp liên quan đến x_pos, self.x_pos mà lớn hơn other_body.x_pos cộng với other_body.width, trường hợp này không thể xảy ra va chạm như vậy đây chúng ta sẽ ghi return False và tương tự self.x_pos cộng thêm cho self.width, tức là vị trí của nó mà cộng thêm cho cái chiều rộng của nó vẫn nhỏ hơn cái other_body.x_pos, trường hợp này không thể xảy ra va chạm như vậy đây chúng ta sẽ tiếp tục return False. Qua bốn cái kiểm tra này mà nó vượt qua hết thì có nghĩa là nó đang va chạm và chúng ta sẽ return ra là True ở đây. Thì đây là một cái hàm để kiểm tra va chạm. Bây giờ chúng ta sẽ sử dụng cái hàm này để test thử một số cái va chạm.
Quay xuống dưới này sau khi vẽ các enemy thì chúng ta sẽ test thử về cái vấn đề kiểm tra va chạm. Rồi bây giờ chúng ta sẽ tạo một cái câu lệnh if player_character.detect_collision, đó là chúng ta sẽ kiểm tra va chạm và nếu đúng thì chúng ta sẽ thực hiện một số cái lệnh nào đó. Bây giờ chúng ta thử kiểm tra va chạm với một cái đối tượng đó là enemy_0, nếu cái này diễn ra thì cái is_game_over của chúng ta ta sẽ cho nó là True, có nghĩa là kết thúc cái vòng lập game luôn và thoát ra ngoài hiển thị một cái dòng thông báo nào đó.
Tuy nhiên thì trước khi mà chúng ta có thể hiển thị một dòng thông báo chúng ta phải khởi tạo được font chữ ra một cái hệ thống font. như vậy ở đây Như vậy ở đây chúng ta sẽ quay lại ở phía trên này. Tại sao careclox thì chúng ta sẽ khởi tạo cái font bằng cách là gọi pygame.font.init và một cái biến font để lưu cái font SysFont vào. font.SysFont rồi.
Ở đây thì chúng ta sẽ cần pygame đây, pygame.font mới chính xác. Chấm SysFont, thì trong cái hàm này chúng ta sẽ đưa vào cái thứ nhất là tên font, thì à một cái phông chữ mà rất quen thuộc với mình đó là phông Arial, cái height là kích thước. Thì kích thước chúng ta sẽ để khoảng 75. Rồi các bạn hoàn toàn có thể thay đổi cái này ví dụ như Timeroman hay là một cái font Roboto chẳng hạn. Kích thước thì chúng ta có thể thay đổi rồi bây giờ chúng ta sẽ quay lại trong cái phần is_game_over. Đây chúng ta sẽ khởi tạo một cái đối tượng text bằng font.render và đưa vào trong đây đó là một cái chữ nào đó ví dụ như Game Over. Thông số thứ hai là chúng ta cần cái phông Arial. Thông số thứ hai đó là Anti Arial thì thôi chúng ta cứ để là True, không ảnh hưởng gì lắm. Thông số thứ ba là cái màu chữ, chúng ta có một cái màu mà chúng ta đã định nghĩa ở trên đó là BLACK_COLOR, ta sẽ sử dụng cái màu này, đương nhiên các bạn hoàn toàn có thể thay đổi cái màu này thành một cái màu nào đó khác. Rồi bắt đầu vẽ cái chữ này ra self.game_screen.blit, các bạn sẽ thấy là vẽ ra giống như là vẽ một cái hình như vậy, đây chúng ta sẽ để là text. Vvị trí: đặt một vị trí ở giữa thì chúng ta có thể thấy là ở giữa là khoảng là 175, 350; 350 sẽ ở giữa theo cái chiều y và 175 thì nó không phải nhất thiết là ở giữa mà nó lệch lệch qua bên trái màn hình như thế này để khi chúng ta hiển thị lên cái chữ thì cái chữ này chúng ta sẽ có cảm giác như ở giữa. Rồi sau khi mà vẽ được cái gì thì nhớ update, pygame.display.update và cuối cùng đó là chúng ta sẽ để một cái dòng pygame.time.delay, 2000, có nghĩa là cái game của mình sẽ dừng lại 2 giây và sau đó chúng ta sẽ break để thoát khỏi vòng lặp game.
Rồi ô kê như vậy thì chúng ta đã viết xong một cái hàm là detect_collision.
Và chúng ta cũng có viết một cái đoạn để test thử cái hàm kiểm tra va chạm này với cái enemy_0. Bây giờ chúng ta sẽ chạy thử để test cái hàm này. Python mygame. Hiện tại thì chúng ta chỉ kiểm tra va chạm với enemy_0 có nghĩa là các nhân vật khác thì không ảnh hưởng gì cả. Đây bây giờ chúng ta thử va chạm với cái enemy ở cuối cùng này, rồi chúng ta thấy là khi va chạm thì nó hiển thị lên chữ Game Over và nó thoát khỏi vòng lặp game và nó tắt luôn cái ứng dụng của mình. Đây chúng ta sẽ thử lại đây va chạm với nhân vật này và Game Over. Như vậy thì chúng ta đã biết được một cái hàm detect_collision và hiện tại nó chạy đúng đắn. Tiếp theo thì chúng ta sẽ thực hiện một số cái kiểm tra là thắng hay thua.
Tiếp theo chúng ta sẽ thực hiện điều kiện thắng và thua trong game. Rõ ràng khi người dùng chạm vào các enemy thì sẽ thua và chúng ta hiển thị lên các Game Over, người dùng chạm vào được rương kho báu thì sẽ chiến thắng và chúng ta sẽ hiển thị lên You win. Rồi bây giờ chúng ta sẽ thực hiện điều đó giờ chúng ta sẽ bỏ đi cái dòng này đi không có test nữa, chúng ta thực hiện luôn nó hoàn toàn có thể sử dụng lại cái đoạn code này. Đây là một cái điều kiện thua, tuy nhiên thì hiện tại chúng ta mới kiểm tra với cái enemy_0 thôi và chúng ta có thể là mở rộng cái này ra cho enemy_1 và enemy_2. Như vậy chúng ta sử dụng điều kiện 0 là nếu nó chạm vào enemy_0 hoặc là chạm vào enemy_1 hoặc là chạm vào enemy_2 thì tất cả đều quy về trường hợp đó là người dùng thua và chúng ta hiển thị lên Game Over. Đây chúng ta sẽ chạy thử đầu tiên chúng ta sẽ cho chạm vào cái enemy_0 thì đây Game Over rồi chạy lại nếu như chạm vào enemy_1 thì cũng Game Over và tương tự đối với trường hợp enemy ở trên cao enemy_2 thì đây chúng ta thấy Game Over rồi.
Chúng ta thấy rằng là cái chữ Game Over này nó hiển thị hơi bị lệch về bên trái, do đó thì chúng ta có thể sửa lại cái con số này. Đây là con số giả định ban đầu nên chúng ta nhắm chừng thôi, do đó chúng ta có thể sửa lại khi các bạn cảm thấy là nó không phù hợp: 275 chúng ta sẽ sửa lại 200. Rồi chạy lại lần nữa. Đây chúng ta thấy là chữ Game Over nó ở giữa hơn, nên các bạn có thể là sửa thêm một lần nữa nếu muốn.6
Đây ví dụ như 225. Rồi ok như vậy thì cái vị trí này là cái vị trí phù hợp, nên các bạn hoàn toàn có thể điều chỉnh những cái vị trí này nếu như các bạn cảm thấy không phù hợp.
Rồi tiếp theo đến điều kiện thắng. Elif. Bây giờ chúng ta sẽ kiểm tra điều kiện thắng nếu cái PlayerCharacter của mình nó chạm được hộp kho báu, thì xem như là thắng và chúng ta sẽ có những điều kiện tương tự như thế này. Rồi ở đây chúng ta sẽ gọi là player_character.detect_collision và va chạm đến treasure thì lúc này thắng. Tất cả những cái này chúng ta có thể sử dụng lại, đây copy xuống is_game_over là True để đảm bảo nó thoát khỏi vòng lặp game. Một text là font.render thì ở đây chúng ta sẽ thay đổi cái chữ đó thôi You win và BLACK_COLOR hiển thị lên (225, 350) rồi display.update và delay 2000. Không có gì thay đổi, chúng ta chỉ thay đổi chữ hiển thị lên mà thôi.
Rồi bây giờ chúng ta sẽ chạy lại ứng dụng của mình. Đây giả sử bây giờ chúng ta vượt qua tất cả những cái enemy và chạm đến hộp kho báu. Đây thì chúng ta sẽ thấy là hiển thị lên You win. Tuy nhiên thì chữ You win nó hơi nhỏ hơn so với chữ Game Over do đó thì chúng ta sẽ đẩy thêm chút xíu nữa. Đây chúng ta sẽ sửa lại là 250 rồi chạy lại. Chúng ta chạy lên You win và chữ You win nó hiển thị ở giữa màn hình.
Như vậy thì trong phần này, chúng ta đã thực hiện được một điều đó là chia ra hai phần kiểm tra điều kiện thắng và điều kiện thua trong game.
Bài học tiếp theo và cũng là cuối cùng thì chúng ta sẽ thực hiện tăng độ khó trò chơi nếu chúng ta lên một level mới.
Trước đó chúng ta đã thực hiện điều kiện thắng và thua trong game. Tuy nhiên nếu thắng hay là thua thì bất kỳ trường hợp nào game cũng sẽ kết thúc và nó thoát đi. Ở đây thì chúng ta sẽ thay đổi chút xíu đó là nếu như thắng thì chúng ta sẽ tiếp tục chơi với một cái level mới và level sau sẽ khó hơn level trước. Như vậy thì trong hàm run_game_loop này là chúng ta sẽ thêm vào một cái thông số đó là thể hiện level. Ở đây tôi gọi là level_speed, bởi vì việc tăng độ khó trò chơi chẳng qua là tăng tốc độ của các nhân vật enemy.
Ở đây tôi sẽ thêm một biến đó là did_win, có nghĩa là nếu như là người dùng thắng thì chúng ta sẽ cho cái did_win này là True để có thể tiếp tục vòng lặp mới. Rồi bây giờ chúng ta sẽ quay về chỗ khởi tạo các enemy và trong cái khởi tạo này chúng ta sẽ thực hiện thêm một điều đó là tăng tốc các enemy tùy theo cái level. Đây chúng ta sẽ tăng tốc các enemy tùy theo level. Việc tăng tốc thì cực kì dễ thôi chúng ta sẽ để lại enemy_0 nhân bằng level SPEED, có nghĩa là level_speed càng cao thì hệ số nhân này nó sẽ nhân lên càng cao. Tương tự enemy_1 chúng ta sẽ nhân level_speed. Tuy nhiên ở đây chúng ta để là trừ 2 cho nó chậm hơn enemy_0 chút xíu. Và tương tự đối với cái enemy_2 nó sẽ nhân bằng level_speed - 4. Rồi đó là cái thứ nhất. Bây giờ chúng ta sẽ chạy thử. 
Đây bây giờ nếu chúng ta chạy thử thì chúng ta thấy rằng là ở đây nó báo là run_game_loop này nó cần một cái element đó là level_speed. Bởi vì chúng ta lúc gọi đến hàm thì chúng ta không có thông số nào cả, chúng ta phải đưa thông số vào đây. 
Rồi bây giờ trong phần thắng thì chúng ta sẽ cần thêm một chút nữa, đó là chúng ta thêm một điều kiện đó là did_win là True là để thể hiện rằng là người dùng để thể hiện rằng là người chơi mới thắng một vòng.
Và cuối cùng sau cái Clock này thì chúng ta kiểm tra xem là nếu người dùng thắng thì chúng ta sẽ cho phép là tăng lên một cái vòng mới. Ta sẽ kiểm tra: nếu thắng thì restart lại game và tăng độ khó. If did_win vậy là người chơi chiến thắng thì đây chúng ta sẽ tự gọi lại cái phương thức run_game_loop với cái level_speed cộng thêm cho 0.5, tức là mỗi lần chúng ta sẽ tăng tốc độ thêm 0.5. Và trong cái run_game_loop này ở bên ngoài chương trình chính thì chúng ta sẽ để cái này là 1, có nghĩa là ban đầu nó chạy giống như là bình thường, sau mỗi lần thì chúng ta sẽ tăng tốc độ lên 0.5. Rồi bây giờ chúng ta có thể chạy thử chương trình của mình. 
Rồi ở đây chúng ta thấy có một cái lỗi xuất hiện đó là enemy nhân bằng level_speed ở đây chúng ta có là enemy_0.SPEED chứ không phải là enemy như thế này. Rồi chúng ta sẽ sửa lại đây ở đây phải là enemy_0.SPEED, cái này tương tự ha enemy_1.SPEED, enemy_2.SPEED. Rồi chúng ta sẽ run lại. Rồi chúng ta thấy là nó chạy. Đây chúng ta sẽ thấy là nó chạy rất nhanh đây rất nhanh như thế này đó. Và rõ ràng đối tượng enemy nè, chạy rất nhanh bởi vì nó trừ và nó trở thành âm, và lúc ban đầu cái level_speed là 1 và nó - 4 ở đây nó là - 3, thì - 3 nó chạy tốc độ là gấp ba lần này. Do đó chúng ta sẽ thêm vào một điều kiện đó là những cái vòng đầu tiên thì sẽ không có enemy_1 và enemy_2. Những nhân vật này nó chỉ xuất hiện trong những vòng cao thôi. 
Rồi bây giờ trong vẽ enemy này chúng ta sẽ thêm vào cái điều kiện if level_speed lớn hơn 2 thì chúng ta mới vẽ các enemy_1 ra, để đảm bảo rằng là ở đây - 2 là hợp lý. Để đảm bảo rằng là tốc độ của enemy_1 ngày nó - 2 là ok. Rồi tiếp theo đối với enemy_2 thì chúng ta sẽ làm kiểm tra level_speed phải lớn hơn 4 thì mới hiển thị enemy ra để đảm bảo rằng là cái speed này mà trừ - 4 thì nó vẫn là chậm hơn cái enemy_0. Rồi chạy thử. 
Đây hiện tại thì chúng ta thấy là có một cái enemy thôi và chúng ta vượt lên. Ở đây có một vấn đề là mặc dù là các enemy này nó không hiện ra, nhưng mà nó vẫn kiểm tra va chạm. Đó là nó đúng vị trí của enemy_1 hoặc là enemy_0, thì cái điều kiện này đúng và nó sẽ báo là Game Over, do đó ở đây chúng ta phải thực hiện thêm một kiểm tra là nếu như nó chưa xuất hiện thì không cần phải kiểm tra cái như thế này. Rồi ở đây chúng ta sẽ để một cái ngoặc nè, đóng lại nè và đây level_speed > 2, tức là từ cái level_speed mà lớn hơn 2 thì chúng ta mới cần phải kiểm tra va chạm đối với các enemy_1. Rồi tương tự như vậy trong trường hợp này chúng ta sẽ để đây level_speed > 4. Rồi chạy lại. Đây chúng ta thấy là có một enemy và chúng ta chạy ở trên này thì nó sẽ không kiểm tra va chạm nữa. Nếu chúng ta chạm vào cái hộp kho báu thì báo là You win” và nó chuyển sang phòng mới. Rồi ok hiện tại thì nó vẫn chưa chuyển sang phòng mới, bây giờ chúng ta sẽ xem lại là lý do ở đâu.
Rồi chúng ta sẽ thấy ở đây break thì nó sẽ nhảy ra khỏi vòng lặp while của chúng ta. Có nghĩa là cái phần kiểm tra thắng để chạy vòng lặp mới thì nó phải nằm bên ngoài vòng lặp while. Đây có nghĩa là chúng ta phải đẩy cái này ra một cái inden. Vòng lặp while đến phần Clock là hết và cái phần kiểm tra thắng thì restart lại game nó phải nằm bên ngoài vòng lặp while. Ở đây chúng ta sẽ chắc ăn chúng ta sẽ thêm một cái else là return. Có nghĩa là nếu cái did_win này là nó False thì chúng ta sẽ kết thúc cái hàm của mình luôn, là kết thúc cái hàm run_game_loop và nó nhảy ra bên ngoài.
Rồi test lại lần nữa. Bây giờ chúng ta sẽ chạy đến hộp kho báu như You win và rõ ràng game không kết thúc và nó và nó chạy qua một vòng mới khó hơn, tốc độ của enemy nhanh hơn. Đây chúng ta sẽ chạy đến. Tiếp tục, đến vòng thứ ba có nghĩa là cái level_speed nó lớn hơn 2. Thì ở đây chúng ta sẽ thấy rằng là xuất hiện thêm một enemy khác. Enemy đầu tiên thì chúng ta thấy là nó chạy một cách điên cuồng do đó bây giờ chúng ta sẽ thay đổi cái speed chút xíu. Kiểu này thì nó không thể vượt qua được. Rồi chúng ta sẽ giảm cái speed lại, cái speed ban đầu nó là 10 thì bây giờ chúng ta sẽ giảm cái này là 5 và chạy lại cái ứng dụng của mình.
Rồi dễ dàng vượt qua chúng ta thấy nhanh hơn rồi và xuất hiện một enemy mới. Rồi tiếp tục chiến thắng và chúng ta thấy rằng là khi mà đến một cái vòng nhất định thì sẽ xuất hiện thêm những cái enemy khác, tạo nên một cái trò chơi càng ngày càng khó hơn. Đương nhiên trò chơi chúng ta nó sẽ không kết thúc cái nhân vật game nhân vật enemy nó chỉ càng ngày càng nhanh thôi và cho đến khi Game Over thì cái code chúng ta nó sẽ thoát ra bên ngoài và nó sẽ kết thúc cái vòng lặp, kết thúc luôn cái ứng dụng của chúng ta.
Như vậy thì chúng ta đã hoàn thành một ứng dụng game hoàn chỉnh, mặc dù đơn giản nhưng mà có đầy đủ những cái chức năng. Và ở đây chúng ta thấy là một số chức năng cần thiết, ví dụ như là: chúng ta tạo được một nhân vật game, tạo được một nhân vật NPC và kiểm tra được một cái va chạm. Với tất cả những cái tính năng này các bạn hoàn toàn có thể tự mình sáng tạo và tạo thêm cho mình những game mới.
## Section 5: Final test và lời kết
### Subsection 5.1: Final test và lời kết
Sau khi kết thúc khóa học thì tôi có một cái project nho nhỏ để các bạn có thể tự mình thực tập và sáng tạo thêm.
Bài tập như sau các bạn sẽ xây dựng một game tiêu diệt quái vật đơn giản. 
Hãy tưởng tượng trái đất đang bị tấn công bởi một nhóm quái vật và bạn hãy tạo ra một game với những tính năng như sau, đương nhiên là các bạn có thể tùy ý sáng tạo.
Xây dựng người chơi player được phép di chuyển trái phải ở bên dưới màn hình và sử dụng một công cụ laser để tiêu diệt quái vật đó là các enemy. 
Khi nhấn nút space, thì một tia laser sẽ được phát ra thẳng đứng từ vị trí của player, player muốn phát ra tia laser khác thì phải chờ một khoảng thời gian được ấn định sẵn. 
Player di chuyển và tiêu diệt các enemy tấn công trái đất, quỹ đạo này thì các bạn có thể tạo ngẫu nhiên hoặc tạo thông qua một hàm nào đó. 
Enemy bị tiêu diệt khi chạm trúng các tia laser. 
Và khi enemy tấn công và chạm đến player thì game sẽ kết thúc, như vậy là game over.
Ở đây thì tôi cũng sẽ có một số tips nho nhỏ để các bạn có thể xây dựng cái project này dễ dàng hơn. 
Thứ nhất là chúng ta sẽ xây dựng người chơi được phép di chuyển trái và phải. Rõ ràng thì cái player này của chúng ta chỉ được phép là trái và phải mà thôi, chúng ta sẽ tắt những cái event liên quan đến những cái nút khác.
Thứ hai khi nhấn nút space thì chúng ta sẽ có một cái tia laser phát ra, như vậy thì chúng ta sẽ kiểm tra cái event đó là một nút space được nhấn.
Khi đó thì chúng ta sẽ vẽ một tia laser và có hướng thẳng đứng từ vị trí của player và hướng thẳng đứng lên. Chúng ta cũng sẽ kiểm tra thêm là trong một cái khoảng thời gian sau khi bắn tia laser, thì người chơi không thể bắn thêm tia laser nào khác.
Thứ ba chúng ta phải vẽ được những enemy thì quỹ đạo enemy này các bạn có thể tạo ra một hàm và chúng ta đưa vào trong đó một số cái ngẫu nhiên để enemy này di chuyển một cách ngẫu nhiên xung quanh cái màn hình của mình. Với hàm va chạm thì chúng ta có thể là tạo một hàm va chạm ở bên trong cái class của enemy. Khi chúng ta kiểm tra enemy này va chạm trúng tia laser thì enemy này sẽ biến mất đi. Nếu enemy này chạm trúng player thì sẽ phát sinh ra một điều kiện là thua và chúng ta sẽ báo là game over.
Đây là những cái tips mà các bạn có thể sử dụng để hoàn thành cái project của mình đơn giản hơn, chúc các bạn thành công.
Chúc mừng các bạn đã hoàn thành khóa học. Trước khi kết thúc hành trình của mình tôi có vài lời chia sẻ thêm với các bạn. Lập trình không chỉ ở việc gõ code và xây dựng những sản phẩm mà là một hành trình đầy sáng tạo và thú vị.
Quá trình học tập có thể xảy ra những khó khăn và thách thức. Tuy nhiên các bạn hãy nhớ rằng mọi khó khăn đều có thể vượt qua. Đôi khi một dòng code nhỏ của các bạn cũng có thể tạo nên sự thay đổi rất lớn. 
Hãy luôn tin tưởng vào khả năng của mình, mỗi bước tiến nhỏ của các bạn đều thật sự đáng tự hào. Đừng ngần ngại hỏi tham khảo và thử nghiệm. 
Làm việc nhóm và hợp tác với người khác sẽ giúp các bạn tiến nhanh hơn trên con đường của mình. 
Cuối cùng đam mê và kiên nhẫn là hai yếu tố quan trọng hãy thỏa sức sáng tạo và dấn thân vào xây dựng nên những sản phẩm thú vị. 
Đôi khi sự thành công không phải là việc không bao giờ thất bại mà là việc không bao giờ từ bỏ. 
Chúc các bạn thành công và vui vẻ với hành trình lập trình và sáng tạo.
Tôi là Trọng Nghĩa chúng ta đang cùng học tại Onlinica.